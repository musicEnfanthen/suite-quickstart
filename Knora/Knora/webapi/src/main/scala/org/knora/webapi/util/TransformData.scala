/*
 * Copyright Â© 2015-2018 the contributors (see Contributors.md).
 *
 * This file is part of Knora.
 *
 * Knora is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Knora is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with Knora.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.knora.webapi.util

import java.io._
import java.util.UUID

import com.typesafe.scalalogging.Logger
import org.eclipse.rdf4j.model.impl.SimpleValueFactory
import org.eclipse.rdf4j.model.{Resource, Statement}
import org.eclipse.rdf4j.rio.turtle._
import org.eclipse.rdf4j.rio.{RDFHandler, RDFWriter}
import org.knora.webapi.messages.admin.responder.permissionsmessages.{PermissionADM, PermissionType}
import org.knora.webapi.messages.v1.responder.valuemessages._
import org.knora.webapi.util.PermissionUtilADM.EntityPermission
import org.knora.webapi.{IRI, InconsistentTriplestoreDataException, OntologyConstants}
import org.rogach.scallop._
import org.slf4j.LoggerFactory

import scala.collection.{SortedSet, mutable}

/**
  * An enumeration of the possible names of a standoff tag submitted as a JSON `textattr`. Note: do not use the `withName` method to get instances
  * of the values of this enumeration; use `lookup` instead, because it reports errors better.
  */
object LegacyTextattrV1 extends Enumeration {

    // internal name / standoff tag name in JSON representation  /  corresponding HTML tag (generated by the GUI)
    val paragraph: LegacyTextattrV1.Value = Value("p")
    // <p>...</p>
    val italic: LegacyTextattrV1.Value = Value("italic")
    // <em>...</em>
    val bold: LegacyTextattrV1.Value = Value("bold")
    // <strong>...</strong>
    val underline: LegacyTextattrV1.Value = Value("underline")
    // <u>...</u>
    val strikethrough: LegacyTextattrV1.Value = Value("strikethrough")
    // <s>...</s>
    val link: LegacyTextattrV1.Value = Value("_link")
    // <a>...</a>
    val header1: LegacyTextattrV1.Value = Value("h1")
    // <h1>...</h1>
    val header2: LegacyTextattrV1.Value = Value("h2")
    // <h2>...</h2>
    val header3: LegacyTextattrV1.Value = Value("h3")
    // <h3>...</h3>
    val header4: LegacyTextattrV1.Value = Value("h4")
    // <h4>...</h4>
    val header5: LegacyTextattrV1.Value = Value("h5")
    // <h5>...</h5>
    val header6: LegacyTextattrV1.Value = Value("h6")
    // <h6>...</h6>
    val superscript: LegacyTextattrV1.Value = Value("sup")
    // <sup>...</sup>
    val subscript: LegacyTextattrV1.Value = Value("sub")
    // <sub>...</sub>
    val orderedList: LegacyTextattrV1.Value = Value("ol")
    // <ol>...</ol>
    val unorderedList: LegacyTextattrV1.Value = Value("ul")
    // <ul>...</ul>
    val listElement: LegacyTextattrV1.Value = Value("li")
    // <li>...</li>
    val styleElement: LegacyTextattrV1.Value = Value("style") // <span>...</span>

    val valueMap: Map[String, Value] = values.map(v => (v.toString, v)).toMap

    /**
      * Given the name of a value in this enumeration, returns the value. If the value is not found, the provided error function is called.
      *
      * @param name     the name of the value.
      * @param errorFun the function to be called in case of an error.
      * @return the requested value.
      */
    def lookup(name: String, errorFun: => Nothing): Value = {
        valueMap.get(name) match {
            case Some(value) => value
            case None => errorFun
        }
    }

    /**
      * Maps standoff tag IRIs to this enumeration's values.
      */
    val iriToEnumValue: Map[IRI, LegacyTextattrV1.Value] = new ErrorHandlingMap(Map(
        OntologyConstants.Standoff.StandoffParagraphTag -> paragraph,
        OntologyConstants.Standoff.StandoffItalicTag -> italic,
        OntologyConstants.Standoff.StandoffBoldTag -> bold,
        OntologyConstants.Standoff.StandoffUnderlineTag -> underline,
        OntologyConstants.Standoff.StandoffStrikethroughTag -> strikethrough,
        OntologyConstants.KnoraBase.StandoffLinkTag -> link,
        OntologyConstants.KnoraBase.StandoffUriTag -> link,
        OntologyConstants.Standoff.StandoffHeader1Tag -> header1,
        OntologyConstants.Standoff.StandoffHeader2Tag -> header2,
        OntologyConstants.Standoff.StandoffHeader3Tag -> header3,
        OntologyConstants.Standoff.StandoffHeader4Tag -> header4,
        OntologyConstants.Standoff.StandoffHeader5Tag -> header5,
        OntologyConstants.Standoff.StandoffHeader6Tag -> header6,
        OntologyConstants.Standoff.StandoffSuperscriptTag -> superscript,
        OntologyConstants.Standoff.StandoffSubscriptTag -> subscript,
        OntologyConstants.Standoff.StandoffOrderedListTag -> orderedList,
        OntologyConstants.Standoff.StandoffUnorderedListTag -> unorderedList,
        OntologyConstants.Standoff.StandoffListElementTag -> listElement,
        OntologyConstants.Standoff.StandoffStyleElementTag -> styleElement
    ), { key => throw InconsistentTriplestoreDataException(s"Invalid standoff tag IRI: $key") })


    // Maps this enumeration's values to standoff tag IRIs.

    val enumValueToIri: Map[LegacyTextattrV1.Value, IRI] = new ErrorHandlingMap(iriToEnumValue.map(_.swap), { key => throw InconsistentTriplestoreDataException(s"Invalid standoff tag name: $key") })
}

/**
  * Updates the structure of Knora repository data to accommodate changes in Knora.
  */
object TransformData extends App {

    private val log = Logger(LoggerFactory.getLogger(this.getClass))

    private val IsDeletedTransformationOption = "deleted"
    private val PermissionsTransformationOption = "permissions"
    private val JulianDayTransformation = "jdn"
    // jdn must be run before strings
    private val MissingValueHasStringTransformationOption = "strings"
    private val StandoffTransformationOption = "standoff"
    private val RegionLabelTransformation = "regionlabels"
    private val CreatorTransformationOption = "creator"
    private val ValueProjectTransformationOption = "valueproject"
    private val OwnerBehaviourTransformationOption = "owner"
    private val AllTransformationsOption = "all"

    private val allTransformations = Vector(
        JulianDayTransformation,
        IsDeletedTransformationOption,
        PermissionsTransformationOption,
        MissingValueHasStringTransformationOption,
        StandoffTransformationOption,
        RegionLabelTransformation,
        ValueProjectTransformationOption,
        CreatorTransformationOption
    )

    private val TempFilePrefix = "TransformData"
    private val TempFileSuffix = ".ttl"

    private val HasRestrictedViewPermission = "http://www.knora.org/ontology/knora-base#hasRestrictedViewPermission"
    private val HasViewPermission = "http://www.knora.org/ontology/knora-base#hasViewPermission"
    private val HasModifyPermission = "http://www.knora.org/ontology/knora-base#hasModifyPermission"
    private val HasDeletePermission = "http://www.knora.org/ontology/knora-base#hasDeletePermission"
    private val HasChangeRightsPermission = "http://www.knora.org/ontology/knora-base#hasChangeRightsPermission"
    private val HasChangeRightsPermisson = "http://www.knora.org/ontology/knora-base#hasChangeRightsPermisson" // This misspelling occurs in some old test data

    private val allOldPermissions = Set(
        HasRestrictedViewPermission,
        HasViewPermission,
        HasModifyPermission,
        HasDeletePermission,
        HasChangeRightsPermission,
        HasChangeRightsPermisson
    )

    private val oldPermissionIri2EntityPermission: Map[IRI, EntityPermission] = Map(
        HasRestrictedViewPermission -> PermissionUtilADM.RestrictedViewPermission,
        HasViewPermission -> PermissionUtilADM.ViewPermission,
        HasModifyPermission -> PermissionUtilADM.ModifyPermission,
        HasDeletePermission -> PermissionUtilADM.DeletePermission,
        HasChangeRightsPermission -> PermissionUtilADM.ChangeRightsPermission,
        HasChangeRightsPermisson -> PermissionUtilADM.ChangeRightsPermission
    )

    private val StandardClassesWithoutIsDeleted = Set(
        OntologyConstants.KnoraBase.User,
        OntologyConstants.KnoraBase.UserGroup,
        OntologyConstants.KnoraBase.KnoraProject,
        OntologyConstants.KnoraBase.Institution,
        OntologyConstants.KnoraBase.ListNode
    )

    private val ValueHasStartJDC = "http://www.knora.org/ontology/knora-base#valueHasStartJDC"
    private val ValueHasEndJDC = "http://www.knora.org/ontology/knora-base#valueHasEndJDC"

    /* Owner and Creator in their shortened format as found inside 'knora-base:hasPermissions' literal */
    private val Owner = "knora-base:Owner"
    private val Creator = "knora-base:Creator"

    // A Map of old standoff class IRIs to new ones
    private val standoffClassMap = Map(
        "http://www.knora.org/ontology/knora-base#StandoffRootTag" -> OntologyConstants.Standoff.StandoffRootTag,
        "http://www.knora.org/ontology/knora-base#StandoffParagraphTag" -> OntologyConstants.Standoff.StandoffParagraphTag,
        "http://www.knora.org/ontology/knora-base#StandoffItalicTag" -> OntologyConstants.Standoff.StandoffItalicTag,
        "http://www.knora.org/ontology/knora-base#StandoffBoldTag" -> OntologyConstants.Standoff.StandoffBoldTag,
        "http://www.knora.org/ontology/knora-base#StandoffUnderlineTag" -> OntologyConstants.Standoff.StandoffUnderlineTag,
        "http://www.knora.org/ontology/knora-base#StandoffStrikethroughTag" -> OntologyConstants.Standoff.StandoffStrikethroughTag,
        "http://www.knora.org/ontology/knora-base#StandoffHeader1Tag" -> OntologyConstants.Standoff.StandoffHeader1Tag,
        "http://www.knora.org/ontology/knora-base#StandoffHeader2Tag" -> OntologyConstants.Standoff.StandoffHeader2Tag,
        "http://www.knora.org/ontology/knora-base#StandoffHeader3Tag" -> OntologyConstants.Standoff.StandoffHeader3Tag,
        "http://www.knora.org/ontology/knora-base#StandoffHeader4Tag" -> OntologyConstants.Standoff.StandoffHeader4Tag,
        "http://www.knora.org/ontology/knora-base#StandoffHeader5Tag" -> OntologyConstants.Standoff.StandoffHeader5Tag,
        "http://www.knora.org/ontology/knora-base#StandoffHeader6Tag" -> OntologyConstants.Standoff.StandoffHeader6Tag,
        "http://www.knora.org/ontology/knora-base#StandoffSuperscriptTag" -> OntologyConstants.Standoff.StandoffSuperscriptTag,
        "http://www.knora.org/ontology/knora-base#StandoffSubscriptTag" -> OntologyConstants.Standoff.StandoffSubscriptTag,
        "http://www.knora.org/ontology/knora-base#StandoffOrderedListTag" -> OntologyConstants.Standoff.StandoffOrderedListTag,
        "http://www.knora.org/ontology/knora-base#StandoffUnorderedListTag" -> OntologyConstants.Standoff.StandoffUnorderedListTag,
        "http://www.knora.org/ontology/knora-base#StandoffListElementTag" -> OntologyConstants.Standoff.StandoffListElementTag,
        "http://www.knora.org/ontology/knora-base#StandoffStyleTag" -> OntologyConstants.Standoff.StandoffStyleElementTag
    )

    private val conf = new TransformDataConf(args)
    private val transformationOption = conf.transform()
    private val inputFile = new File(conf.input())
    private val outputFile = new File(conf.output())

    if (transformationOption == AllTransformationsOption) {
        runAllTransformations(inputFile, outputFile)
    } else {
        runTransformation(transformationOption, inputFile, outputFile)
    }

    /**
      * Runs all transformations, using temporary files as needed.
      *
      * @param inputFile  the input file.
      * @param outputFile the output file.
      */
    private def runAllTransformations(inputFile: File, outputFile: File): Unit = {
        /**
          * Associates a transformation with an input file and and output file, either of which may be a temporary file.
          *
          * @param transformation     the name of the transformation.
          * @param inputFileForTrans  the input file to be used for the transformation.
          * @param outputFileForTrans the output file to be used for the transformation.
          */
        case class TransformationWithFiles(transformation: String, inputFileForTrans: File, outputFileForTrans: File)

        // Make a list of transformations to be run, with an input file and an output file for each one, generating
        // temporary file names as needed.
        val transformationsWithFiles: Vector[TransformationWithFiles] = allTransformations.foldLeft(Vector.empty[TransformationWithFiles]) {
            case (acc, trans) =>
                // Is this is the first transformation?
                val inputFileForTrans = if (trans == allTransformations.head) {
                    // Yes. Use the user's input file as the input file for the transformation.
                    inputFile
                } else {
                    // No. Use the previous transformation's output file as the input file for this transformation.
                    acc.last.outputFileForTrans
                }

                // Is this the last transformation?
                val outputFileForTrans = if (trans == allTransformations.last) {
                    // Yes. Use the user's output file as the output file for the transformation.
                    outputFile
                } else {
                    // No. Use a temporary file.
                    File.createTempFile(TempFilePrefix, TempFileSuffix)
                }

                acc :+ TransformationWithFiles(
                    transformation = trans,
                    inputFileForTrans = inputFileForTrans,
                    outputFileForTrans = outputFileForTrans
                )
        }

        // Run all the transformations.
        for (transformationWithFiles <- transformationsWithFiles) {
            runTransformation(
                transformation = transformationWithFiles.transformation,
                inputFile = transformationWithFiles.inputFileForTrans,
                outputFile = transformationWithFiles.outputFileForTrans
            )
        }
    }

    /**
      * Runs the specified transformation.
      *
      * @param transformation the name of the transformation to be run.
      * @param inputFile      the input file.
      * @param outputFile     the output file.
      */
    private def runTransformation(transformation: String, inputFile: File, outputFile: File): Unit = {
        // println(s"Running transformation $transformation with inputFile $inputFile and outputFile $outputFile")

        val fileInputStream = new FileInputStream(inputFile)
        val fileOutputStream = new FileOutputStream(outputFile)
        val turtleParser = new TurtleParser()
        val turtleWriter = new TurtleWriter(fileOutputStream)

        val handler = transformation match {
            case IsDeletedTransformationOption => new IsDeletedHandler(turtleWriter)
            case PermissionsTransformationOption => new PermissionsHandler(turtleWriter)
            case MissingValueHasStringTransformationOption => new ValueHasStringHandler(turtleWriter)
            case StandoffTransformationOption => new StandoffHandler(turtleWriter)
            case RegionLabelTransformation => new RegionLabelHandler(turtleWriter)
            case JulianDayTransformation => new JDNHandler(turtleWriter)
            case ValueProjectTransformationOption => new ValueProjectHandler(turtleWriter)
            case CreatorTransformationOption => new CreatorHandler(turtleWriter)
            case OwnerBehaviourTransformationOption => new OwnerBehaviourHandler(turtleWriter)
            case _ => throw new Exception(s"Unsupported transformation $transformation")
        }

        turtleParser.setRDFHandler(handler)
        turtleParser.parse(fileInputStream, inputFile.getAbsolutePath)
        fileOutputStream.close()
        fileInputStream.close()
    }

    /**
      * Looks for regions that have the label "test" and changes their label to the value of their `knora-base:hasComment`.
      *
      * @param turtleWriter an [[RDFWriter]] that writes to the output file.
      */
    private class RegionLabelHandler(turtleWriter: RDFWriter) extends StatementCollectingHandler(turtleWriter: RDFWriter) {
        override def endRDF(): Unit = {
            statements.foreach {
                case (_, subjectStatements: Vector[Statement]) =>
                    val subjectType = subjectStatements.find(_.getPredicate.stringValue == OntologyConstants.Rdf.Type).get.getObject.stringValue
                    val label = subjectStatements.find(_.getPredicate.stringValue == OntologyConstants.Rdfs.Label).map(_.getObject.stringValue)

                    val newLabel = if (subjectType == OntologyConstants.KnoraBase.Region && (label.isEmpty || label.contains("test"))) {
                        val commentIri = subjectStatements.find(_.getPredicate.stringValue == OntologyConstants.KnoraBase.HasComment).get.getObject.stringValue
                        Some(statements(valueFactory.createIRI(commentIri)).find(_.getPredicate.stringValue == OntologyConstants.KnoraBase.ValueHasString).get.getObject.stringValue)
                    } else {
                        label
                    }

                    subjectStatements.foreach {
                        statement =>
                            val newStatement = if (statement.getPredicate.stringValue == OntologyConstants.Rdfs.Label) {
                                valueFactory.createStatement(
                                    statement.getSubject,
                                    statement.getPredicate,
                                    valueFactory.createLiteral(newLabel.get)
                                )
                            } else {
                                statement
                            }

                            turtleWriter.handleStatement(newStatement)
                    }

            }

            turtleWriter.endRDF()
        }
    }

    /**
      * Adds `knora-base:isDeleted false` to resources and values that don't have a `knora-base:isDeleted` predicate.
      *
      * @param turtleWriter an [[RDFWriter]] that writes to the output file.
      */
    private class IsDeletedHandler(turtleWriter: RDFWriter) extends StatementCollectingHandler(turtleWriter: RDFWriter) {
        override def endRDF(): Unit = {
            statements.foreach {
                case (_, subjectStatements: Vector[Statement]) =>
                    // Check whether the subject already has a knora-base:isDeleted predicate.
                    val hasIsDeleted = subjectStatements.exists(_.getPredicate.stringValue == OntologyConstants.KnoraBase.IsDeleted)
                    val isStandoff = subjectStatements.exists(_.getPredicate.stringValue == OntologyConstants.KnoraBase.StandoffTagHasStart)

                    subjectStatements.foreach {
                        statement =>
                            turtleWriter.handleStatement(statement)

                            // If this statement provides the rdf:type of the subject, and the subject doesn't have a
                            // knora-base:isDeleted predicate, check whether it needs one.
                            if (statement.getPredicate.stringValue == OntologyConstants.Rdf.Type && !hasIsDeleted) {
                                val rdfType = statement.getObject.stringValue

                                // If the rdf:type isn't one of the standard classes that can't be marked as deleted,
                                // and the subject isn't a standoff tag, assume it must be a Resource or Value,
                                // and add knora-base:isDeleted false.
                                if (!(StandardClassesWithoutIsDeleted.contains(rdfType) || isStandoff)) {
                                    val isDeletedStatement = valueFactory.createStatement(
                                        statement.getSubject,
                                        valueFactory.createIRI(OntologyConstants.KnoraBase.IsDeleted),
                                        valueFactory.createLiteral(false)
                                    )

                                    turtleWriter.handleStatement(isDeletedStatement)
                                }
                            }
                    }
            }

            turtleWriter.endRDF()
        }
    }

    /**
      * Transforms old-style Knora permissions statements into new-style permissions statements.
      *
      * @param turtleWriter an [[RDFWriter]] that writes to the output file.
      */
    private class PermissionsHandler(turtleWriter: RDFWriter) extends StatementCollectingHandler(turtleWriter: RDFWriter) {
        override def endRDF(): Unit = {
            statements.foreach {
                case (subject: Resource, subjectStatements: Vector[Statement]) =>
                    // Write the statements about each resource.
                    val subjectPermissions = subjectStatements.foldLeft(Map.empty[EntityPermission, Set[IRI]]) {
                        case (acc, st) =>
                            val predicateStr = st.getPredicate.stringValue

                            // If a statement describes an old-style permission, save it.
                            if (allOldPermissions.contains(predicateStr)) {
                                val group = st.getObject.stringValue()
                                val accessPermission = oldPermissionIri2EntityPermission(predicateStr)
                                val currentGroupsForPermission = acc.getOrElse(accessPermission, Set.empty[IRI])
                                acc + (accessPermission -> (currentGroupsForPermission + group))
                            } else {
                                // Otherwise, write it.
                                turtleWriter.handleStatement(st)
                                acc
                            }
                    }

                    // Write the resource's permissions as a single statement.
                    if (subjectPermissions.nonEmpty) {
                        val permissionADMs: Set[PermissionADM] = subjectPermissions.toVector.flatMap {
                            case (accessPermission, groups) => groups.map {
                                group =>
                                    PermissionADM(
                                        name = accessPermission.toString,
                                        additionalInformation = Some(group),
                                        permissionCode = Some(accessPermission.toInt)
                                    )
                            }
                        }.toSet

                        val permissionLiteral = PermissionUtilADM.formatPermissionADMs(permissionADMs, PermissionType.OAP)

                        val permissionStatement = valueFactory.createStatement(
                            subject,
                            valueFactory.createIRI(OntologyConstants.KnoraBase.HasPermissions),
                            valueFactory.createLiteral(permissionLiteral)
                        )

                        turtleWriter.handleStatement(permissionStatement)
                    }
            }

            turtleWriter.endRDF()
        }
    }

    /**
      * Adds missing `knora-base:valueHasString` statements.
      *
      * @param turtleWriter an [[RDFWriter]] that writes to the output file.
      */
    private class ValueHasStringHandler(turtleWriter: RDFWriter) extends StatementCollectingHandler(turtleWriter: RDFWriter) {

        private def maybeWriteValueHasString(subject: Resource, subjectStatements: Vector[Statement]): Unit = {
            val resourceClass = getObject(subjectStatements, OntologyConstants.Rdf.Type).get

            // Is this Knora value object?
            if (resourceClass.startsWith(OntologyConstants.KnoraBase.KnoraBasePrefixExpansion) && resourceClass.endsWith("Value")) {
                // Yes. Does it already have a valueHasString?
                val maybeValueHasStringStatement: Option[Statement] = subjectStatements.find(_.getPredicate.stringValue == OntologyConstants.KnoraBase.ValueHasString)

                if (maybeValueHasStringStatement.isEmpty) {
                    // No. Generate one.

                    val stringLiteral = resourceClass match {
                        case OntologyConstants.KnoraBase.IntValue => getObject(subjectStatements, OntologyConstants.KnoraBase.ValueHasInteger).get
                        case OntologyConstants.KnoraBase.BooleanValue => getObject(subjectStatements, OntologyConstants.KnoraBase.ValueHasBoolean).get
                        case OntologyConstants.KnoraBase.UriValue => getObject(subjectStatements, OntologyConstants.KnoraBase.ValueHasUri).get
                        case OntologyConstants.KnoraBase.DecimalValue => getObject(subjectStatements, OntologyConstants.KnoraBase.ValueHasDecimal).get

                        case OntologyConstants.KnoraBase.DateValue =>
                            val startJDN = getObject(subjectStatements, OntologyConstants.KnoraBase.ValueHasStartJDN).get
                            val endJDN = getObject(subjectStatements, OntologyConstants.KnoraBase.ValueHasEndJDN).get
                            val startPrecision = getObject(subjectStatements, OntologyConstants.KnoraBase.ValueHasStartPrecision).get
                            val endPrecision = getObject(subjectStatements, OntologyConstants.KnoraBase.ValueHasEndPrecision).get
                            val calendar = getObject(subjectStatements, OntologyConstants.KnoraBase.ValueHasCalendar).get

                            val jdnValue = JulianDayNumberValueV1(
                                dateval1 = startJDN.toInt,
                                dateval2 = endJDN.toInt,
                                calendar = KnoraCalendarV1.lookup(calendar),
                                dateprecision1 = KnoraPrecisionV1.lookup(startPrecision),
                                dateprecision2 = KnoraPrecisionV1.lookup(endPrecision)
                            )

                            jdnValue.toString

                        case OntologyConstants.KnoraBase.ColorValue => getObject(subjectStatements, OntologyConstants.KnoraBase.ValueHasColor).get
                        case OntologyConstants.KnoraBase.GeomValue => getObject(subjectStatements, OntologyConstants.KnoraBase.ValueHasGeometry).get
                        case OntologyConstants.KnoraBase.StillImageFileValue => getObject(subjectStatements, OntologyConstants.KnoraBase.OriginalFilename).get
                        case OntologyConstants.KnoraBase.ListValue => getObject(subjectStatements, OntologyConstants.KnoraBase.ValueHasListNode).get

                        case OntologyConstants.KnoraBase.IntervalValue =>
                            val intervalStart = getObject(subjectStatements, OntologyConstants.KnoraBase.ValueHasIntervalStart).get
                            val intervalEnd = getObject(subjectStatements, OntologyConstants.KnoraBase.ValueHasIntervalEnd).get

                            val intervalValue = IntervalValueV1(
                                timeval1 = BigDecimal(intervalStart),
                                timeval2 = BigDecimal(intervalEnd)
                            )

                            intervalValue.toString

                        case OntologyConstants.KnoraBase.GeonameValue => getObject(subjectStatements, OntologyConstants.KnoraBase.ValueHasGeonameCode).get
                        case OntologyConstants.KnoraBase.LinkValue => getObject(subjectStatements, OntologyConstants.Rdf.Object).get

                        case _ => throw InconsistentTriplestoreDataException(s"Unsupported value type $resourceClass")
                    }

                    val valueHasStringStatement = valueFactory.createStatement(
                        subject,
                        valueFactory.createIRI(OntologyConstants.KnoraBase.ValueHasString),
                        valueFactory.createLiteral(stringLiteral)
                    )

                    turtleWriter.handleStatement(valueHasStringStatement)
                }
            }
        }

        override def endRDF(): Unit = {
            statements.foreach {
                case (subject: Resource, subjectStatements: Vector[Statement]) =>
                    subjectStatements.foreach(st => turtleWriter.handleStatement(st))
                    maybeWriteValueHasString(subject, subjectStatements)
            }

            turtleWriter.endRDF()
        }
    }

    /**
      * Changes standoff blank nodes into `StandoffTag` objects.
      *
      * @param turtleWriter an [[RDFWriter]] that writes to the output file.
      */
    private class StandoffHandler(turtleWriter: RDFWriter) extends StatementCollectingHandler(turtleWriter: RDFWriter) {
        private val knoraIdUtil = new KnoraIdUtil

        // The obsolete standoffHasAttribute predicate.
        private val StandoffHasAttribute = OntologyConstants.KnoraBase.KnoraBasePrefixExpansion + "standoffHasAttribute"

        // A Map of some old standoff class names to new ones.
        private val oldToNewClassIris = Map(
            OntologyConstants.KnoraBase.KnoraBasePrefixExpansion + "StandoffLink" -> OntologyConstants.KnoraBase.StandoffLinkTag,
            OntologyConstants.KnoraBase.KnoraBasePrefixExpansion + "StandoffHref" -> OntologyConstants.KnoraBase.StandoffUriTag
        )

        private val StandoffHasStart = OntologyConstants.KnoraBase.KnoraBasePrefixExpansion + "standoffHasStart"
        private val StandoffHasEnd = OntologyConstants.KnoraBase.KnoraBasePrefixExpansion + "standoffHasEnd"

        // A map of old standoff predicates to new ones.
        private val oldToNewPredicateIris = Map(
            StandoffHasStart -> OntologyConstants.KnoraBase.StandoffTagHasStart,
            StandoffHasEnd -> OntologyConstants.KnoraBase.StandoffTagHasEnd,
            OntologyConstants.KnoraBase.KnoraBasePrefixExpansion + "standoffHasLink" -> OntologyConstants.KnoraBase.StandoffTagHasLink,
            OntologyConstants.KnoraBase.KnoraBasePrefixExpansion + "standoffHasHref" -> OntologyConstants.KnoraBase.ValueHasUri
        )

        override def endRDF(): Unit = {
            // Make a flat list of all statements in the data.
            val allStatements: Vector[Statement] = statements.values.flatten.toVector

            // A Map of standoff tag IRIs to their containing text value IRIs.
            val standoffTagIrisToTextValueIris = new mutable.HashMap[IRI, IRI]()

            // A Map of old standoff tag blank node identifiers to new standoff tag IRIs.
            val standoffTagIriMap = mutable.HashMap[IRI, IRI]()

            // Populate standoffTagIriMap and standoffTagIrisToTextValueIris.
            for (statement <- allStatements) {
                val predicate = statement.getPredicate.stringValue()

                // Does this statement point to a standoff node?
                if (predicate == OntologyConstants.KnoraBase.ValueHasStandoff) {
                    // Yes.
                    val valueObjectIri = statement.getSubject.stringValue()
                    val oldStandoffIri = statement.getObject.stringValue()

                    // Is the object an old-style blank node identifier?
                    val standoffTagIri = if (!oldStandoffIri.contains("/standoff/")) {
                        // Yes. Make a new IRI for it.
                        val newStandoffIri = knoraIdUtil.makeRandomStandoffTagIri(valueObjectIri)
                        standoffTagIriMap += (oldStandoffIri -> newStandoffIri)
                        newStandoffIri
                    } else {
                        oldStandoffIri
                    }

                    standoffTagIrisToTextValueIris += (standoffTagIri -> valueObjectIri)
                }
            }

            // Replace blank node identifiers with IRIs.
            val statementsWithNewIris = allStatements.map {
                statement =>
                    val subject = statement.getSubject.stringValue()
                    val predicate = statement.getPredicate.stringValue()
                    val obj = statement.getObject
                    val objStr = statement.getObject.stringValue()

                    // If the subject is a standoff blank node identifier, replace it with the corresponding IRI.
                    val newSubject = standoffTagIriMap.getOrElse(subject, subject)

                    // If the object is a standoff blank node identifier, replace it with the corresponding IRI.
                    val newObject = predicate match {
                        case OntologyConstants.KnoraBase.ValueHasStandoff =>
                            valueFactory.createIRI(standoffTagIriMap.getOrElse(objStr, objStr))

                        case _ => obj
                    }

                    valueFactory.createStatement(
                        valueFactory.createIRI(newSubject),
                        valueFactory.createIRI(predicate),
                        newObject
                    )
            }

            // Separate out the statements about standoff tags, and group them by subject IRI.
            val standoffTagIris = standoffTagIrisToTextValueIris.keySet
            val (standoffStatements: Vector[Statement], nonStandoffStatements: Vector[Statement]) = statementsWithNewIris.partition(statement => standoffTagIris.contains(statement.getSubject.stringValue()))
            val groupedStandoffStatements: Map[Resource, Vector[Statement]] = standoffStatements.groupBy(_.getSubject)

            // A data structure to store the positions of linefeeds to be inserted in text values, replacing linebreak tags.
            val linefeedsToInsert = new mutable.HashMap[IRI, SortedSet[Int]]

            // IRIs of removed standoff linebreak tags.
            val removedLinebreakTagIris = new mutable.HashSet[IRI]

            // Remove the linebreak tags.
            val standoffWithoutLinebreakTags: Map[Resource, Vector[Statement]] = groupedStandoffStatements.filter {
                case (tag, tagStatements) =>
                    getObject(tagStatements, StandoffHasAttribute) match {
                        case Some("linebreak") =>
                            // If we got a linebreak tag, delete it and save its position so we can add a linefeed to the text value later.
                            val tagIri = tag.stringValue()
                            val textValueIri = standoffTagIrisToTextValueIris(tagIri)
                            val currentLinefeedsForTextValue = linefeedsToInsert.getOrElse(textValueIri, SortedSet.empty[Int])
                            val linefeedPos = getObject(tagStatements, StandoffHasStart).get.toInt
                            linefeedsToInsert += (textValueIri -> (currentLinefeedsForTextValue + linefeedPos))
                            removedLinebreakTagIris += tagIri
                            false

                        case _ => true
                    }
            }

            // Transform the structure of each standoff tag.
            val transformedStandoff: Vector[Statement] = standoffWithoutLinebreakTags.flatMap {
                case (tag: Resource, tagStatements: Seq[Statement]) =>
                    val oldTagClassIri = getObject(tagStatements, OntologyConstants.Rdf.Type).get
                    val textValueIri = standoffTagIrisToTextValueIris(tag.stringValue)
                    val linefeedsToInsertForTextValue = linefeedsToInsert.get(textValueIri)
                    val maybeTagName = getObject(tagStatements, StandoffHasAttribute)

                    val newTagClassIri = maybeTagName match {
                        case Some(tagName) =>
                            if (tagName == "_link") {
                                oldToNewClassIris(oldTagClassIri)
                            } else {
                                // Otherwise, generate the new class name from the tag name.
                                LegacyTextattrV1.enumValueToIri(LegacyTextattrV1.lookup(tagName, throw InconsistentTriplestoreDataException(s"Unrecognised standoff tag name $tagName")))
                            }

                        case None => oldTagClassIri
                    }

                    // Throw away the standoffHasAttribute statement.
                    val tagStatementsWithoutStandoffHasAttribute = tagStatements.filterNot(_.getPredicate.stringValue == StandoffHasAttribute)

                    // If the tag doesn't have a UUID, create one.
                    val maybeUuidStatement = getObject(tagStatements, OntologyConstants.KnoraBase.StandoffTagHasUUID) match {
                        case Some(_) => None
                        case None => Some(
                            valueFactory.createStatement(
                                tag,
                                valueFactory.createIRI(OntologyConstants.KnoraBase.StandoffTagHasUUID),
                                valueFactory.createLiteral(UUID.randomUUID.toString)
                            )
                        )
                    }

                    // Transform the remaining statements.
                    tagStatementsWithoutStandoffHasAttribute.map {
                        statement =>
                            val oldPredicate = statement.getPredicate.stringValue

                            oldPredicate match {
                                case OntologyConstants.Rdf.Type =>
                                    // Replace the old rdf:type with the new one.
                                    valueFactory.createStatement(
                                        statement.getSubject,
                                        statement.getPredicate,
                                        valueFactory.createIRI(newTagClassIri)
                                    )

                                case StandoffHasStart =>
                                    val currentStartPos = statement.getObject.stringValue.toInt

                                    val newStartPos = linefeedsToInsertForTextValue match {
                                        case Some(linefeeds) =>
                                            // Count the number of linefeeds whose positions are less than or equal
                                            // to the current value of standoffHasStart, and increment standoffHasStart
                                            // by that number.
                                            val linefeedsToInsertBeforeTag = linefeeds.count(_ <= currentStartPos)
                                            currentStartPos + linefeedsToInsertBeforeTag

                                        case None => currentStartPos
                                    }

                                    valueFactory.createStatement(
                                        statement.getSubject,
                                        valueFactory.createIRI(oldToNewPredicateIris(StandoffHasStart)),
                                        valueFactory.createLiteral(newStartPos)
                                    )

                                case StandoffHasEnd =>
                                    val currentEndPos = statement.getObject.stringValue.toInt

                                    val newEndPos = linefeedsToInsertForTextValue match {
                                        case Some(linefeeds) =>

                                            // Count the number of linefeeds whose positions are less than
                                            // to the current value of standoffHasEnd, and increment standoffHasEnd
                                            // by that number.
                                            val linefeedsToInsertBeforeTag = linefeeds.count(_ < currentEndPos)
                                            currentEndPos + linefeedsToInsertBeforeTag

                                        case None => currentEndPos
                                    }

                                    valueFactory.createStatement(
                                        statement.getSubject,
                                        valueFactory.createIRI(oldToNewPredicateIris(StandoffHasEnd)),
                                        valueFactory.createLiteral(newEndPos)
                                    )

                                case _ =>
                                    // Replace other old predicates with new ones.
                                    valueFactory.createStatement(
                                        statement.getSubject,
                                        valueFactory.createIRI(oldToNewPredicateIris.getOrElse(oldPredicate, oldPredicate)),
                                        statement.getObject
                                    )
                            }
                    } ++ maybeUuidStatement
            }.toVector

            // Fix the objects of valueHasString by replacing \r with INFORMATION SEPARATOR TWO and inserting
            // linefeeds that were previously represented as "linebreak" standoff tags.
            val transformedNonStandoffStatements = nonStandoffStatements.foldLeft(Vector.empty[Statement]) {
                case (acc, statement) =>
                    statement.getPredicate.stringValue match {
                        case OntologyConstants.KnoraBase.ValueHasString =>
                            // Replace \r with INFORMATION SEPARATOR TWO.
                            val objectWithSeparators = statement.getObject.stringValue.replace('\r', StringFormatter.INFORMATION_SEPARATOR_TWO)

                            // Insert linefeeds that were previously represented as "linebreak" standoff tags.
                            val objectWithLinefeeds: String = linefeedsToInsert.get(statement.getSubject.stringValue) match {
                                case Some(linefeeds) =>
                                    // Each time we add a linefeed to the string, the positions of all the remaining
                                    // linefeeds to be added must be shifted to the right. Do this shifting in advance,
                                    // by adding the position of each linefeed to its index.
                                    val adjustedLinefeeds: SortedSet[Int] = linefeeds.zipWithIndex.map {
                                        case (pos, index) => pos + index
                                    }

                                    val stringBuilder = new StringBuilder()

                                    // Make a list of the Unicode code points in the string. We can't just iterate over
                                    // the Char values in the string, because the JVM uses UTF-16 internally, and it uses
                                    // surrogate pairs of Chars for Unicode values that won't fit in a 16-bit Char. So
                                    // a single character could actually be represented by two UTF-16 Chars. We assume
                                    // that a standoff position is the index of a code point.

                                    val codePoints: Vector[String] = objectWithSeparators.codePoints.toArray.toVector.map {
                                        codePoint => new String(Character.toChars(codePoint))
                                    }

                                    // Iterate over the code points in the string, adding line feeds at the appropriate
                                    // positions.
                                    for ((codePointStr, pos) <- codePoints.zipWithIndex) {
                                        if (adjustedLinefeeds.contains(pos)) {
                                            stringBuilder.append('\n')
                                        }

                                        stringBuilder.append(codePointStr)
                                    }

                                    stringBuilder.toString

                                case None => objectWithSeparators
                            }

                            acc :+ valueFactory.createStatement(
                                statement.getSubject,
                                statement.getPredicate,
                                valueFactory.createLiteral(objectWithLinefeeds)
                            )

                        case OntologyConstants.KnoraBase.ValueHasStandoff if removedLinebreakTagIris.contains(statement.getObject.stringValue) =>
                            // This is a valueHasStandoff statement referring to a linebreak tag that was removed, so ignore it.
                            acc

                        case _ => acc :+ statement
                    }
            }

            // Recombine the transformed standoff tags with the rest of the statements in the data.
            val allTransformedStatements = transformedStandoff ++ transformedNonStandoffStatements

            val groupedBySubject: Map[IRI, Vector[Statement]] = allTransformedStatements.groupBy(st => st.getSubject.stringValue())

            val standoffLinkValues: Map[IRI, Vector[Statement]] = groupedBySubject.filter {
                case (subjectIri: IRI, statements: Seq[Statement]) =>
                    statements.exists {
                        (statement: Statement) =>
                            statement.getPredicate.stringValue == OntologyConstants.Rdf.Type &&
                                statement.getObject.stringValue == OntologyConstants.KnoraBase.LinkValue
                    } && statements.exists {
                        (statement: Statement) =>
                            statement.getPredicate.stringValue == OntologyConstants.Rdf.Predicate &&
                                statement.getObject.stringValue == OntologyConstants.KnoraBase.HasStandoffLinkTo
                    }
            }

            val transformedStandoffLinkValues = standoffLinkValues.map {
                case (subjectIri: IRI, statements: Seq[Statement]) =>
                    val statementsWithoutCreatorOrPermissions = statements.filterNot {
                        (statement: Statement) =>
                            statement.getPredicate.stringValue == OntologyConstants.KnoraBase.AttachedToUser ||
                                statement.getPredicate.stringValue == OntologyConstants.KnoraBase.HasPermissions
                    }

                    val creatorStatement = valueFactory.createStatement(
                        valueFactory.createIRI(subjectIri),
                        valueFactory.createIRI(OntologyConstants.KnoraBase.AttachedToUser),
                        valueFactory.createIRI(OntologyConstants.KnoraBase.SystemUser)
                    )

                    val permissionsStatement = valueFactory.createStatement(
                        valueFactory.createIRI(subjectIri),
                        valueFactory.createIRI(OntologyConstants.KnoraBase.HasPermissions),
                        valueFactory.createLiteral("CR knora-base:Creator|V knora-base:UnknownUser")
                    )

                    val transformedLinkValueStatements = statementsWithoutCreatorOrPermissions :+ creatorStatement :+ permissionsStatement
                    subjectIri -> transformedLinkValueStatements
            }

            val textValues: Map[IRI, Vector[Statement]] = groupedBySubject.filter {
                case (subjectIri: IRI, statements: Seq[Statement]) =>
                    statements.exists {
                        (statement: Statement) =>
                            statement.getPredicate.stringValue == OntologyConstants.Rdf.Type &&
                                statement.getObject.stringValue == OntologyConstants.KnoraBase.TextValue
                    }
            }

            val textValuesAndStandoff: Map[IRI, Map[IRI, Vector[Statement]]] = textValues.map {
                case (textValueIri: IRI, statements: Seq[Statement]) =>
                    val standoffIris: Seq[IRI] = statements.filter(_.getPredicate.stringValue == OntologyConstants.KnoraBase.ValueHasStandoff).map(_.getObject.stringValue)

                    val standoffNodes: Map[IRI, Vector[Statement]] = standoffIris.map {
                        nodeIri => (nodeIri, groupedBySubject(nodeIri))
                    }.toMap

                    (textValueIri, standoffNodes)
            }

            val allStandoff: Map[IRI, Vector[Statement]] = textValuesAndStandoff.values.flatten.toMap

            val transformedEverything: Vector[Statement] = groupedBySubject.flatMap {
                case (subjectIri: IRI, statements: Vector[Statement]) =>
                    if (allStandoff.contains(subjectIri) || transformedStandoffLinkValues.contains(subjectIri)) {
                        // Ignore standoff nodes and standoff link values because we're going to replace them
                        Vector.empty[Statement]
                    } else if (textValues.contains(subjectIri)) {
                        // Generate transformed text value and standoff

                        val textValueStandoff: Map[IRI, Vector[Statement]] = textValuesAndStandoff(subjectIri)

                        // If the text value has no standoff, leave it as is
                        if (textValueStandoff.isEmpty) {
                            statements
                        } else {
                            val mappingToAdd: Option[Statement] = if (!statements.exists(_.getPredicate.stringValue == OntologyConstants.KnoraBase.ValueHasMapping)) {
                                Some(
                                    valueFactory.createStatement(
                                        valueFactory.createIRI(subjectIri),
                                        valueFactory.createIRI(OntologyConstants.KnoraBase.ValueHasMapping),
                                        valueFactory.createIRI(OntologyConstants.KnoraBase.StandardMapping)
                                    )
                                )
                            } else {
                                None
                            }

                            val tagStatementsWithNewClasses: Map[IRI, Vector[Statement]] = textValueStandoff.map {
                                case (standoffNodeIri, standoffNodeStatements) =>
                                    val statementsWithNewClasses = standoffNodeStatements.map {
                                        statement =>
                                            if (statement.getPredicate.stringValue == OntologyConstants.Rdf.Type) {
                                                standoffClassMap.get(statement.getObject.stringValue) match {
                                                    case Some(newClassIri) =>
                                                        valueFactory.createStatement(
                                                            statement.getSubject,
                                                            statement.getPredicate,
                                                            valueFactory.createIRI(newClassIri)
                                                        )

                                                    case None => statement
                                                }
                                            } else {
                                                statement
                                            }
                                    }

                                    (standoffNodeIri, statementsWithNewClasses)
                            }

                            val hasRootTag = tagStatementsWithNewClasses.exists {
                                case (_, standoffNodeStatements) =>
                                    standoffNodeStatements.exists {
                                        statement =>
                                            statement.getPredicate.stringValue == OntologyConstants.Rdf.Type &&
                                                statement.getObject.stringValue == OntologyConstants.Standoff.StandoffRootTag
                                    }
                            }

                            val standoffWithRootTag: Vector[Statement] = if (hasRootTag) {
                                tagStatementsWithNewClasses.values.flatten.toVector
                            } else {
                                val rootTagIri = knoraIdUtil.makeRandomStandoffTagIri(subjectIri)
                                val textLength = getObject(statements, OntologyConstants.KnoraBase.ValueHasString).getOrElse(throw InconsistentTriplestoreDataException(s"Text value $subjectIri has no knora-base:valueHasString")).length

                                val rootTag = Vector(
                                    valueFactory.createStatement(
                                        valueFactory.createIRI(subjectIri),
                                        valueFactory.createIRI(OntologyConstants.KnoraBase.ValueHasStandoff),
                                        valueFactory.createIRI(rootTagIri)
                                    ),
                                    valueFactory.createStatement(
                                        valueFactory.createIRI(rootTagIri),
                                        valueFactory.createIRI(OntologyConstants.Rdf.Type),
                                        valueFactory.createIRI(OntologyConstants.Standoff.StandoffRootTag)
                                    ),
                                    valueFactory.createStatement(
                                        valueFactory.createIRI(rootTagIri),
                                        valueFactory.createIRI(OntologyConstants.KnoraBase.StandoffTagHasStart),
                                        valueFactory.createLiteral(0)
                                    ),
                                    valueFactory.createStatement(
                                        valueFactory.createIRI(rootTagIri),
                                        valueFactory.createIRI(OntologyConstants.KnoraBase.StandoffTagHasEnd),
                                        valueFactory.createLiteral(textLength)
                                    ),
                                    valueFactory.createStatement(
                                        valueFactory.createIRI(rootTagIri),
                                        valueFactory.createIRI(OntologyConstants.KnoraBase.StandoffTagHasUUID),
                                        valueFactory.createLiteral(UUID.randomUUID.toString)
                                    ),
                                    valueFactory.createStatement(
                                        valueFactory.createIRI(rootTagIri),
                                        valueFactory.createIRI(OntologyConstants.KnoraBase.StandoffTagHasStartIndex),
                                        valueFactory.createLiteral(0)
                                    )
                                )

                                val otherTags: Vector[Statement] = tagStatementsWithNewClasses.flatMap {
                                    case (tagIri, tagStatements) =>
                                        val parentToAdd = if (!tagStatements.exists(_.getPredicate.stringValue == OntologyConstants.KnoraBase.StandoffTagHasStartParent)) {
                                            Some(
                                                valueFactory.createStatement(
                                                    valueFactory.createIRI(tagIri),
                                                    valueFactory.createIRI(OntologyConstants.KnoraBase.StandoffTagHasStartParent),
                                                    valueFactory.createIRI(rootTagIri)
                                                )
                                            )
                                        } else {
                                            None
                                        }

                                        val indexStatement = getObject(tagStatements, OntologyConstants.KnoraBase.StandoffTagHasStartIndex) match {
                                            case Some(existingIndex) =>
                                                valueFactory.createStatement(
                                                    valueFactory.createIRI(tagIri),
                                                    valueFactory.createIRI(OntologyConstants.KnoraBase.StandoffTagHasStartIndex),
                                                    valueFactory.createLiteral(existingIndex.toInt + 1)
                                                )

                                            case None =>
                                                valueFactory.createStatement(
                                                    valueFactory.createIRI(tagIri),
                                                    valueFactory.createIRI(OntologyConstants.KnoraBase.StandoffTagHasStartIndex),
                                                    valueFactory.createLiteral(1)
                                                )
                                        }

                                        val tagStatementsWithCorrectIndexes = tagStatements.filterNot(_.getPredicate.stringValue == OntologyConstants.KnoraBase.StandoffTagHasStartIndex)

                                        tagStatementsWithCorrectIndexes ++ parentToAdd :+ indexStatement
                                }.toVector

                                otherTags ++ rootTag
                            }

                            statements ++ standoffWithRootTag ++ mappingToAdd
                        }
                    } else {
                        // Not a text value, standoff node, or standoff link value, so leave as is
                        statements
                    }
            }.toVector ++ transformedStandoffLinkValues.values.flatten

            // Sort them by subject IRI.
            val sortedStatements = transformedEverything.sortBy(_.getPredicate.stringValue).sortBy(_.getSubject.stringValue())

            // Write them to the output file.
            for (statement <- sortedStatements) {
                turtleWriter.handleStatement(statement)
            }

            turtleWriter.endRDF()
        }
    }


    /**
      * Replaces `knora-base:valueHasStartJDC` with `knora-base:valueHasStartJDN` and `knora-base:valueHasEndJDC`
      * with `knora-base:valueHasEndJDN`.
      *
      * @param turtleWriter an [[RDFWriter]] that writes to the output file.
      */
    private class JDNHandler(turtleWriter: RDFWriter) extends RDFHandler {
        private val valueFactory = SimpleValueFactory.getInstance()

        override def handleComment(comment: IRI): Unit = {
            turtleWriter.handleComment(comment)
        }

        override def handleStatement(st: Statement): Unit = {
            val newPredicate = st.getPredicate.stringValue match {
                case ValueHasStartJDC => valueFactory.createIRI(OntologyConstants.KnoraBase.ValueHasStartJDN)
                case ValueHasEndJDC => valueFactory.createIRI(OntologyConstants.KnoraBase.ValueHasEndJDN)
                case _ => st.getPredicate
            }

            turtleWriter.handleStatement(valueFactory.createStatement(
                st.getSubject,
                newPredicate,
                st.getObject
            ))
        }

        override def endRDF(): Unit = {
            turtleWriter.endRDF()
        }

        override def handleNamespace(prefix: IRI, uri: IRI): Unit = {
            turtleWriter.handleNamespace(prefix, uri)
        }

        override def startRDF(): Unit = {
            turtleWriter.startRDF()
        }
    }

    /**
      * Removes `knora-base:attachedToProject` from Knora values.
      *
      * @param turtleWriter an [[RDFWriter]] that writes to the output file.
      */
    private class ValueProjectHandler(turtleWriter: RDFWriter) extends StatementCollectingHandler(turtleWriter: RDFWriter) {
        override def endRDF(): Unit = {
            statements.foreach {
                case (subject: Resource, subjectStatements: Vector[Statement]) =>
                    val rdfType = getObject(subjectStatements = subjectStatements, predicateIri = OntologyConstants.Rdf.Type).getOrElse(s"Subject $subject has no rdf:type")

                    val statementsToWrite = if (OntologyConstants.KnoraBase.ValueClasses.contains(rdfType)) {
                        subjectStatements.filter(_.getPredicate.stringValue != OntologyConstants.KnoraBase.AttachedToProject)
                    } else {
                        subjectStatements
                    }

                    statementsToWrite.foreach {
                        statement => turtleWriter.handleStatement(statement)
                    }
            }

            turtleWriter.endRDF()
        }
    }

    /**
      * Transforms existing 'knora-base:Owner' group inside permissions statements to 'knora-base:Creator'
      *
      * @param turtleWriter an [[RDFWriter]] that writes to the output file.
      */
    private class CreatorHandler(turtleWriter: RDFWriter) extends StatementCollectingHandler(turtleWriter: RDFWriter) {
        override def endRDF(): Unit = {

            statements.foreach {
                case (_, subjectStatements: Vector[Statement]) =>

                    subjectStatements.foreach {
                        statement =>
                            // If this statement has the 'hasPermissions' predicate, then see if the literal contains
                            // 'knora-base:Owner', and if so, replace with 'knora-base:Creator'.
                            if (statement.getPredicate.stringValue == OntologyConstants.KnoraBase.HasPermissions) {

                                //log.debug(s"CreatorHandler - ${ScalaPrettyPrinter.prettyPrint(statement)}")

                                val permissionsLiteral: String = statement.getObject.stringValue()

                                if (permissionsLiteral.contains(Owner)) {
                                    /* literal contains 'Owner' so I need to change it */
                                    val changedPermissionsLiteral = permissionsLiteral.replace(Owner, Creator)

                                    /* create statement with new literal */
                                    val newHasPermissionsStatement = valueFactory.createStatement(
                                        statement.getSubject,
                                        statement.getPredicate,
                                        valueFactory.createLiteral(changedPermissionsLiteral)
                                    )

                                    /* write statement with changed literal */
                                    turtleWriter.handleStatement(newHasPermissionsStatement)
                                } else {
                                    /* literal does not contain 'Owner' so I can write it as it is */
                                    turtleWriter.handleStatement(statement)
                                }
                            } else {
                                /* not an 'hasPermissions' statement */
                                turtleWriter.handleStatement(statement)
                            }
                    }

            }

            turtleWriter.endRDF()
        }
    }

    /**
      * Adds 'knora-base:Creator' group to 'CR' permission statement. This corresponds to the previous behaviour with
      * 'knora-base:Owner'. Use carefully as it will add permissions that where not there before.
      *
      * @param turtleWriter an [[RDFWriter]] that writes to the output file.
      */
    private class OwnerBehaviourHandler(turtleWriter: RDFWriter) extends StatementCollectingHandler(turtleWriter: RDFWriter) {
        override def endRDF(): Unit = {

            val standoffNodeIris: Set[IRI] = statements.values.flatten.filter(_.getPredicate.stringValue == OntologyConstants.KnoraBase.ValueHasStandoff).map(_.getObject.stringValue).toSet

            statements.foreach {
                case (subject: Resource, subjectStatements: Vector[Statement]) =>

                    if (standoffNodeIris.contains(subject.stringValue)) {
                        subjectStatements.foreach {
                            statement => turtleWriter.handleStatement(statement)
                        }
                    } else {
                        val currentPermissions: Set[PermissionADM] = getObject(subjectStatements, OntologyConstants.KnoraBase.HasPermissions) match {
                            case Some(permissionsLiteral) =>
                                /* parse literal */
                                val parsedPermissions: Set[PermissionADM] = PermissionUtilADM.parsePermissionsWithType(Some(permissionsLiteral), PermissionType.OAP)

                                /* remove ony permissions referencing the creator */
                                parsedPermissions.filter(perm => perm.additionalInformation.get != OntologyConstants.KnoraBase.Creator)

                            case None => Set.empty[PermissionADM]
                        }

                        /* add CR for Creator */
                        val permissionsWithCreator = Set(PermissionADM.changeRightsPermission(OntologyConstants.KnoraBase.Creator)) ++ currentPermissions

                        /* transform back to literal */
                        val changedPermissionsLiteral: String = PermissionUtilADM.formatPermissionADMs(permissionsWithCreator, PermissionType.OAP)

                        /* create statement with new literal */
                        val newHasPermissionsStatement = valueFactory.createStatement(
                            subject,
                            valueFactory.createIRI(OntologyConstants.KnoraBase.HasPermissions),
                            valueFactory.createLiteral(changedPermissionsLiteral)
                        )

                        val subjectStatementsWithChangedPermissions = subjectStatements.filterNot(_.getPredicate.stringValue == OntologyConstants.KnoraBase.HasPermissions) :+ newHasPermissionsStatement

                        subjectStatementsWithChangedPermissions.foreach {
                            statement => turtleWriter.handleStatement(statement)
                        }
                    }
            }

            turtleWriter.endRDF()
        }
    }


    /**
      * Parses command-line arguments.
      */
    private class TransformDataConf(arguments: Seq[String]) extends ScallopConf(arguments) {
        banner(
            s"""
               |Updates the structure of Knora repository data to accommodate changes in Knora.
               |
               |Usage: org.knora.webapi.util.TransformData -t [$IsDeletedTransformationOption|$PermissionsTransformationOption|$MissingValueHasStringTransformationOption|$StandoffTransformationOption|$RegionLabelTransformation|$JulianDayTransformation|$ValueProjectTransformationOption|$CreatorTransformationOption|$OwnerBehaviourTransformationOption|$AllTransformationsOption] input output
            """.stripMargin)

        val transform: ScallopOption[String] = opt[String](
            required = true,
            validate = t => Set(IsDeletedTransformationOption, PermissionsTransformationOption, MissingValueHasStringTransformationOption, StandoffTransformationOption, RegionLabelTransformation, JulianDayTransformation, ValueProjectTransformationOption, CreatorTransformationOption, OwnerBehaviourTransformationOption, AllTransformationsOption).contains(t),
            descr = s"Selects a transformation. Available transformations: '$IsDeletedTransformationOption' (adds missing 'knora-base:isDeleted' statements), '$PermissionsTransformationOption' (combines old-style multiple permission statements into single permission statements), '$MissingValueHasStringTransformationOption' (adds missing valueHasString), '$StandoffTransformationOption' (transforms old-style standoff into new-style standoff), '$RegionLabelTransformation' (fixes the labels of regions whose label is 'test'), '$JulianDayTransformation' (changes Julian Day Count to Julian Day Number), '$ValueProjectTransformationOption' (removes 'knora-base:attachedToProject' from values), '$CreatorTransformationOption' (transforms existing 'knora-base:Owner' group inside permissions to 'knora-base:Creator'), '$OwnerBehaviourTransformationOption' (gives 'knora-base:Creator' CR permissions to correspond to the previous behaviour for owners - use with care as it will add permissions that where not there before), '$AllTransformationsOption' (all of the above minus '$OwnerBehaviourTransformationOption')"
        )

        val input: ScallopOption[String] = trailArg[String](required = true, descr = "Input Turtle file")
        val output: ScallopOption[String] = trailArg[String](required = true, descr = "Output Turtle file")
        verify()
    }

}
