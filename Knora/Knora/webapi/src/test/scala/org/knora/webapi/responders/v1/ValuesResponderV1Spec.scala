/*
 * Copyright © 2015-2018 the contributors (see Contributors.md).
 *
 * This file is part of Knora.
 *
 * Knora is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Knora is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with Knora.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.knora.webapi.responders.v1

import java.util.UUID

import akka.actor.Props
import akka.testkit.{ImplicitSender, TestActorRef}
import com.typesafe.config.ConfigFactory
import org.knora.webapi.SharedOntologyTestDataADM._
import org.knora.webapi.SharedTestDataADM._
import org.knora.webapi._
import org.knora.webapi.messages.store.triplestoremessages._
import org.knora.webapi.messages.v1.responder.ontologymessages._
import org.knora.webapi.messages.v1.responder.resourcemessages.{LocationV1, ResourceFullGetRequestV1, ResourceFullResponseV1}
import org.knora.webapi.messages.v1.responder.sipimessages.SipiResponderConversionFileRequestV1
import org.knora.webapi.messages.v2.responder.standoffmessages.{MappingXMLtoStandoff, StandoffDataTypeClasses, XMLTag}
import org.knora.webapi.messages.v1.responder.valuemessages._
import org.knora.webapi.responders._
import org.knora.webapi.store.{STORE_MANAGER_ACTOR_NAME, StoreManager}
import org.knora.webapi.twirl.{StandoffTagIriAttributeV2, StandoffTagV2}
import org.knora.webapi.util.MutableTestIri

import scala.concurrent.duration._

/**
  * Static data for testing [[ValuesResponderV1]].
  */
object ValuesResponderV1Spec {

    val config = ConfigFactory.parseString(
        """
         akka.loglevel = "DEBUG"
         akka.stdout-loglevel = "DEBUG"
        """.stripMargin)

    private val incunabulaProjectIri = INCUNABULA_PROJECT_IRI
    private val anythingProjectIri = ANYTHING_PROJECT_IRI

    private val zeitglöckleinIri = "http://rdfh.ch/c5058f3a"
    private val miscResourceIri = "http://rdfh.ch/miscResource"
    private val aThingIri = "http://rdfh.ch/0001/a-thing"

    private val incunabulaUser = SharedTestDataADM.incunabulaMemberUser

    private val imagesUser = SharedTestDataADM.imagesUser01

    private val anythingUser = SharedTestDataADM.anythingUser1

    private val versionHistoryWithHiddenVersion = ValueVersionHistoryGetResponseV1(
        valueVersions = Vector(
            ValueVersionV1(
                previousValue = None, // The user doesn't have permission to see the previous value.
                valueCreationDate = Some("2016-01-22T11:31:24Z"),
                valueObjectIri = "http://rdfh.ch/21abac2162/values/f76660458201"
            ),
            ValueVersionV1(
                previousValue = None,
                valueCreationDate = Some("2016-01-20T11:31:24Z"),
                valueObjectIri = "http://rdfh.ch/21abac2162/values/11111111"
            )
        )
    )
}

/**
  * Tests [[ValuesResponderV1]].
  */
class ValuesResponderV1Spec extends CoreSpec(ValuesResponderV1Spec.config) with ImplicitSender {

    import ValuesResponderV1Spec._

    val responderManager = system.actorOf(Props(new TestResponderManager(Map(SIPI_ROUTER_V1_ACTOR_NAME -> system.actorOf(Props(new MockSipiResponderV1))))), name = RESPONDER_MANAGER_ACTOR_NAME)

    val rdfDataObjects = Vector(
        RdfDataObject(path = "_test_data/responders.v1.ValuesResponderV1Spec/incunabula-data.ttl", name = "http://www.knora.org/data/0803/incunabula"),
        RdfDataObject(path = "_test_data/demo_data/images-demo-data.ttl", name = "http://www.knora.org/data/00FF/images"),
        RdfDataObject(path = "_test_data/all_data/anything-data.ttl", name = "http://www.knora.org/data/0001/anything")
    )
    private val actorUnderTest = TestActorRef[ValuesResponderV1]
    private val storeManager = system.actorOf(Props(new StoreManager with LiveActorMaker), name = STORE_MANAGER_ACTOR_NAME)
    // The default timeout for receiving reply messages from actors.
    private val timeout = 30.seconds

    // IRIs that are generated by tests and used by subsequent tests.
    private val commentIri = new MutableTestIri
    private val firstValueIriWithResourceRef = new MutableTestIri
    private val secondValueIriWithResourceRef = new MutableTestIri
    private val standoffLinkValueIri = new MutableTestIri
    private val currentSeqnumValueIri = new MutableTestIri
    private val currentPubdateValueIri = new MutableTestIri
    private val linkObjLinkValueIri = new MutableTestIri
    private val currentColorValueIri = new MutableTestIri
    private val currentGeomValueIri = new MutableTestIri
    private val partOfLinkValueIri = new MutableTestIri
    // a sample set of standoff tags
    private val sampleStandoff: Vector[StandoffTagV2] = Vector(
        StandoffTagV2(
            standoffTagClassIri = OntologyConstants.Standoff.StandoffBoldTag,
            startPosition = 0,
            endPosition = 7,
            uuid = UUID.randomUUID().toString,
            originalXMLID = None,
            startIndex = 0
        ),
        StandoffTagV2(
            standoffTagClassIri = OntologyConstants.Standoff.StandoffParagraphTag,
            startPosition = 0,
            endPosition = 10,
            uuid = UUID.randomUUID().toString,
            originalXMLID = None,
            startIndex = 0
        )
    )
    private val dummyMapping = MappingXMLtoStandoff(
            namespace = Map.empty[String, Map[String, Map[String, XMLTag]]],
        defaultXSLTransformation = None
    )

    private def checkComment1aResponse(response: CreateValueResponseV1, utf8str: String, standoff: Seq[StandoffTagV2] = Seq.empty[StandoffTagV2]): Unit = {
        assert(response.rights == 8, "rights was not 8")
        assert(response.value.asInstanceOf[TextValueV1].utf8str == utf8str, "comment value did not match")

        if (standoff.nonEmpty) {
            response.value match {
                case textValueWithStandoff: TextValueWithStandoffV1 =>
                    assert(textValueWithStandoff.standoff.sortBy(standoffTag => (standoffTag.standoffTagClassIri, standoffTag.startPosition)) == standoff.sortBy(standoffTag => (standoffTag.standoffTagClassIri, standoffTag.startPosition)), "standoff did not match")
                case _ => assert(false) // response should be of type TextValueWithStandoffV1
            }
        }

        commentIri.set(response.id)
    }

    private def checkValueGetResponse(response: ValueGetResponseV1): Unit = {
        assert(response.rights == 8, "rights was not 8")
        assert(response.value.asInstanceOf[TextValueV1].utf8str == "Comment 1a", "comment value did not match")
    }

    private def checkValueGetResponseWithStandoff(response: ValueGetResponseV1): Unit = {
        assert(response.rights == 6, "rights was not 6")
        assert(response.value.asInstanceOf[TextValueWithStandoffV1].utf8str == "Zusammengebunden mit zwei weiteren Drucken von Johann Amerbach", "comment utf8str value did not match")



        // expected Standoff information for <http://rdfh.ch/e41ab5695c/values/d3398239089e04> in incunabula-data.ttl
        val standoff = Vector(
            StandoffTagV2(
                standoffTagClassIri = OntologyConstants.Standoff.StandoffRootTag,
                startPosition = 0,
                endPosition = 62,
                uuid = "4800e53e-3835-498e-b658-6cc4f93ab894",
                originalXMLID = None,
                startIndex = 0
            ), StandoffTagV2(
                standoffTagClassIri = OntologyConstants.Standoff.StandoffBoldTag,
                startPosition = 21,
                endPosition = 25,
                uuid = "4bc24696-5dde-4ced-9687-6f8e4519efe8",
                originalXMLID = None,
                startIndex = 1,
                startParentIndex = Some(0)
            )
        )

        assert(response.value.asInstanceOf[TextValueWithStandoffV1].standoff.sortBy(_.standoffTagClassIri) == standoff.sortBy(_.standoffTagClassIri), "standoff did not match")
    }

    private def checkComment1bResponse(response: ChangeValueResponseV1, utf8str: String, standoff: Seq[StandoffTagV2] = Seq.empty[StandoffTagV2]): Unit = {
        assert(response.rights == 8, "rights was not 8")

        assert(response.value.asInstanceOf[TextValueV1].utf8str == utf8str, "comment value did not match")


        if (standoff.nonEmpty) {
            response.value match {
                case textValueWithStandoff: TextValueWithStandoffV1 =>
                    assert(textValueWithStandoff.standoff.sortBy(standoffTag => (standoffTag.standoffTagClassIri, standoffTag.startPosition)) == standoff.sortBy(standoffTag => (standoffTag.standoffTagClassIri, standoffTag.startPosition)), "standoff did not match")
                case _ => assert(false) // response should be of type TextValueWithStandoffV1
            }
        }

        commentIri.set(response.id)
    }

    private def checkOrderInResource(response: ResourceFullResponseV1): Unit = {
        val comments = response.props.get.properties.filter(_.pid == "http://www.knora.org/ontology/0803/incunabula#book_comment").head

        assert(comments.values == Vector(
            TextValueSimpleV1(utf8str = "Comment 1b"),
            TextValueSimpleV1("Comment 2")
        ), "Values of book_comment did not match")
    }

    private def checkTextValue(expected: TextValueV1, received: TextValueV1): Unit = {

        assert(received.utf8str == expected.utf8str)

        // if standoff is expected, compare the standoff tags
        expected match {

            case expectedWithStandoff: TextValueWithStandoffV1 =>
                assert(received.asInstanceOf[TextValueWithStandoffV1].resource_reference == expectedWithStandoff.resource_reference)
                assert(received.asInstanceOf[TextValueWithStandoffV1].standoff.map(_.standoffTagClassIri).sorted == expectedWithStandoff.standoff.map(_.standoffTagClassIri).sorted)
                assert(received.asInstanceOf[TextValueWithStandoffV1].standoff.sortBy(standoffTag => (standoffTag.standoffTagClassIri, standoffTag.startPosition)) == expectedWithStandoff.standoff.sortBy(standoffTag => (standoffTag.standoffTagClassIri, standoffTag.startPosition)))
            case _ =>
        }

    }

    private def getLastModificationDate(resourceIri: IRI): Option[String] = {
        val lastModSparqlQuery = queries.sparql.v1.txt.getLastModificationDate(
            triplestore = settings.triplestoreType,
            resourceIri = resourceIri
        ).toString()

        storeManager ! SparqlSelectRequest(lastModSparqlQuery)

        expectMsgPF(timeout) {
            case response: SparqlSelectResponse =>
                val rows = response.results.bindings
                assert(rows.size <= 1, s"Resource $resourceIri has more than one instance of knora-base:lastModificationDate")

                if (rows.size == 1) {
                    Some(rows.head.rowMap("lastModificationDate"))
                } else {
                    None
                }
        }
    }

    private def checkImageFileValueChange(received: ChangeFileValueResponseV1, request: ChangeFileValueRequestV1): Unit = {
        assert(received.locations.size == 2, "Expected two file values to have been changed (thumb and full quality)")

        received.locations.foreach {
            location: LocationV1 => assert(location.origname == request.file.originalFilename, "wrong original file name")
        }
    }


    "Load test data" in {
        storeManager ! ResetTriplestoreContent(rdfDataObjects)
        expectMsg(300.seconds, ResetTriplestoreContentACK())

        responderManager ! LoadOntologiesRequest(SharedTestDataADM.rootUser)
        expectMsg(30.seconds, LoadOntologiesResponse())
    }

    "The values responder" should {
        "add a new text value without Standoff" in {
            val lastModBeforeUpdate = getLastModificationDate(zeitglöckleinIri)

            val utf8str = "Comment 1a"

            actorUnderTest ! CreateValueRequestV1(
                resourceIri = zeitglöckleinIri,
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#book_comment",
                value = TextValueSimpleV1(utf8str = utf8str),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: CreateValueResponseV1 => checkComment1aResponse(msg, utf8str)
            }

            // Check that the resource's last modification date got updated.
            val lastModAfterUpdate = getLastModificationDate(zeitglöckleinIri)
            lastModBeforeUpdate != lastModAfterUpdate should ===(true)
        }

        "attempt to add a duplicate text value without standoff" in {

            val utf8str = "Comment 1a"

            actorUnderTest ! CreateValueRequestV1(
                resourceIri = zeitglöckleinIri,
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#book_comment",
                value = TextValueSimpleV1(utf8str = utf8str),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[DuplicateValueException] should ===(true)
            }


        }

        "query a text value without Standoff" in {
            actorUnderTest ! ValueGetRequestV1(
                valueIri = commentIri.get,
                userProfile = incunabulaUser
            )

            expectMsgPF(timeout) {
                case msg: ValueGetResponseV1 => checkValueGetResponse(msg)
            }
        }

        "query a text value containing Standoff" in {
            actorUnderTest ! ValueGetRequestV1(
                valueIri = "http://rdfh.ch/e41ab5695c/values/d3398239089e04",
                userProfile = incunabulaUser
            )

            expectMsgPF(timeout) {
                case msg: ValueGetResponseV1 =>
                    checkValueGetResponseWithStandoff(msg)
            }
        }

        "query a standoff link as an ordinary value" in {
            actorUnderTest ! ValueGetRequestV1(
                valueIri = "http://rdfh.ch/0001/a-thing-with-text-values/values/0",
                userProfile = incunabulaUser
            )

            expectMsgPF(timeout) {
                case msg: ValueGetResponseV1 => msg.rights should ===(2)
            }
        }

        "query a LinkValue" in {
            actorUnderTest ! LinkValueGetRequestV1(
                subjectIri = "http://rdfh.ch/8a0b1e75",
                predicateIri = "http://www.knora.org/ontology/0803/incunabula#partOf",
                objectIri = zeitglöckleinIri,
                userProfile = incunabulaUser
            )

            expectMsgPF(timeout) {
                case msg: ValueGetResponseV1 =>
                    msg.valuetype should ===(OntologyConstants.KnoraBase.LinkValue)
                    msg.value should ===(LinkValueV1(
                        subjectIri = "http://rdfh.ch/8a0b1e75",
                        predicateIri = "http://www.knora.org/ontology/0803/incunabula#partOf",
                        objectIri = zeitglöckleinIri,
                        referenceCount = 1
                    ))
                    msg.rights should ===(2)
            }
        }

        "add a new version of a text value without Standoff" in {
            val lastModBeforeUpdate = getLastModificationDate(zeitglöckleinIri)

            val utf8str = "Comment 1b"

            actorUnderTest ! ChangeValueRequestV1(
                valueIri = commentIri.get,
                value = TextValueSimpleV1(utf8str = utf8str),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: ChangeValueResponseV1 => checkComment1bResponse(msg, utf8str)
            }

            // Check that the resource's last modification date got updated.
            val lastModAfterUpdate = getLastModificationDate(zeitglöckleinIri)
            lastModBeforeUpdate != lastModAfterUpdate should ===(true)
        }

        "not add a new version of a value that's exactly the same as the current version" in {
            val utf8str = "Comment 1b"

            actorUnderTest ! ChangeValueRequestV1(
                valueIri = commentIri.get,
                value = TextValueSimpleV1(utf8str = utf8str),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[DuplicateValueException] should ===(true)
            }
        }

        "not create a new value that would duplicate an existing value" in {
            val utf8str = "Comment 1b"

            actorUnderTest ! CreateValueRequestV1(
                resourceIri = zeitglöckleinIri,
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#book_comment",
                value = TextValueSimpleV1(utf8str = utf8str),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[DuplicateValueException] should ===(true)
            }
        }

        "not add a new version of a value that would duplicate an existing value" in {
            val utf8str = "GW 4168"

            actorUnderTest ! ChangeValueRequestV1(
                valueIri = "http://rdfh.ch/c5058f3a/values/184e99ca01",
                value = TextValueSimpleV1(utf8str = utf8str),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[DuplicateValueException] should ===(true)
            }
        }

        "insert valueHasOrder correctly for each value" in {
            actorUnderTest ! CreateValueRequestV1(
                resourceIri = zeitglöckleinIri,
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#book_comment",
                value = TextValueSimpleV1("Comment 2"),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: CreateValueResponseV1 => ()
            }

            responderManager ! ResourceFullGetRequestV1(
                iri = zeitglöckleinIri,
                userADM = incunabulaUser
            )

            expectMsgPF(timeout) {
                case msg: ResourceFullResponseV1 => checkOrderInResource(msg)
            }
        }

        "return the version history of a value" in {
            actorUnderTest ! ValueVersionHistoryGetRequestV1(
                resourceIri = zeitglöckleinIri,
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#book_comment",
                currentValueIri = commentIri.get,
                userProfile = incunabulaUser
            )

            expectMsgPF(timeout) {
                case msg: ValueVersionHistoryGetResponseV1 => msg.valueVersions.length should ===(2)
            }
        }

        "mark a value as deleted" in {
            val lastModBeforeUpdate = getLastModificationDate(zeitglöckleinIri)

            actorUnderTest ! DeleteValueRequestV1(
                valueIri = commentIri.get,
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: DeleteValueResponseV1 => commentIri.set(msg.id)
            }

            actorUnderTest ! ValueGetRequestV1(
                valueIri = commentIri.get,
                userProfile = incunabulaUser
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[NotFoundException] should ===(true)
            }

            // Check that the resource's last modification date got updated.
            val lastModAfterUpdate = getLastModificationDate(zeitglöckleinIri)
            lastModBeforeUpdate != lastModAfterUpdate should ===(true)
        }

        "not add a new value to a nonexistent resource" in {
            actorUnderTest ! CreateValueRequestV1(
                resourceIri = "http://rdfh.ch/nonexistent",
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#book_comment",
                value = TextValueSimpleV1("Comment 1"),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[NotFoundException] should ===(true)
            }
        }

        "not add a new value to a deleted resource" in {
            actorUnderTest ! CreateValueRequestV1(
                resourceIri = "http://rdfh.ch/9935159f67",
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#book_comment",
                value = TextValueSimpleV1("Comment 1"),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[NotFoundException] should ===(true)
            }
        }

        "not add a new version of a deleted value" in {
            actorUnderTest ! ChangeValueRequestV1(
                valueIri = commentIri.get,
                value = TextValueSimpleV1("Comment 1c"),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[NotFoundException] should ===(true)
            }
        }

        "not add a new value to a resource that the user doesn't have permission to modify" in {
            actorUnderTest ! CreateValueRequestV1(
                resourceIri = "http://rdfh.ch/e41ab5695c",
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#book_comment",
                value = TextValueSimpleV1("Comment 1"),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[ForbiddenException] should ===(true)
            }
        }

        "not add a new value of the wrong type" in {
            actorUnderTest ! CreateValueRequestV1(
                resourceIri = "http://rdfh.ch/21abac2162",
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#pubdate",
                value = TextValueSimpleV1("this is not a date"),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[OntologyConstraintException] should ===(true)
            }
        }

        "not add a new version to a value that the user doesn't have permission to modify" in {
            actorUnderTest ! ChangeValueRequestV1(
                valueIri = "http://rdfh.ch/c5058f3a/values/c3295339",
                value = TextValueSimpleV1("Zeitglöcklein des Lebens und Leidens Christi modified"),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[ForbiddenException] should ===(true)
            }
        }

        "not add a new version of a value of the wrong type" in {
            actorUnderTest ! ChangeValueRequestV1(
                valueIri = "http://rdfh.ch/c5058f3a/values/cfd09f1e01",
                value = TextValueSimpleV1("this is not a date"),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure =>
                    msg.cause.isInstanceOf[OntologyConstraintException] should ===(true)
            }
        }

        "not add a new value that would violate a cardinality restriction" in {
            // The cardinality of incunabula:partOf in incunabula:page is 1, and page http://rdfh.ch/4f11adaf is already part of a book.
            actorUnderTest ! CreateValueRequestV1(
                resourceIri = "http://rdfh.ch/4f11adaf",
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#partOf",
                value = LinkUpdateV1(targetResourceIri = "http://rdfh.ch/e41ab5695c"),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[OntologyConstraintException] should ===(true)
            }

            // The cardinality of incunabula:seqnum in incunabula:page is 0-1, and page http://rdfh.ch/4f11adaf already has a seqnum.
            actorUnderTest ! CreateValueRequestV1(
                resourceIri = "http://rdfh.ch/4f11adaf",
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#seqnum",
                value = IntegerValueV1(1),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[OntologyConstraintException] should ===(true)
            }
        }

        "hide versions the user doesn't have permission to see" in {
            actorUnderTest ! ValueVersionHistoryGetRequestV1(
                resourceIri = "http://rdfh.ch/21abac2162",
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#title",
                currentValueIri = "http://rdfh.ch/21abac2162/values/f76660458201",
                userProfile = incunabulaUser
            )

            expectMsg(timeout, versionHistoryWithHiddenVersion)
        }


        "create a color value" in {

            val color = "#000000"

            actorUnderTest ! CreateValueRequestV1(
                resourceIri = miscResourceIri,
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#miscHasColor",
                value = ColorValueV1(color),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID)

            expectMsgPF(timeout) {
                case msg: CreateValueResponseV1 =>
                    currentColorValueIri.set(msg.id)
                    msg.value should ===(ColorValueV1(color))
            }
        }

        "change an existing color value" in {

            val color = "#FFFFFF"

            actorUnderTest ! ChangeValueRequestV1(
                value = ColorValueV1(color),
                userProfile = incunabulaUser,
                valueIri = currentColorValueIri.get,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: ChangeValueResponseV1 =>
                    currentColorValueIri.set(msg.id)
                    msg.value should ===(ColorValueV1(color))
            }
        }

        "create a geometry value" in {

            val geom = "{\"status\":\"active\",\"lineColor\":\"#ff3333\",\"lineWidth\":2,\"points\":[{\"x\":0.5516074450084602,\"y\":0.4444444444444444},{\"x\":0.2791878172588832,\"y\":0.5}],\"type\":\"rectangle\",\"original_index\":0}"

            actorUnderTest ! CreateValueRequestV1(
                resourceIri = miscResourceIri,
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#miscHasGeometry",
                value = GeomValueV1(geom),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID)

            expectMsgPF(timeout) {
                case msg: CreateValueResponseV1 =>
                    currentGeomValueIri.set(msg.id)
                    msg.value should ===(GeomValueV1(geom))
            }

        }

        "change a geometry value for a region" in {

            val geom = "{\"status\":\"active\",\"lineColor\":\"#ff4433\",\"lineWidth\":1,\"points\":[{\"x\":0.5516074450084602,\"y\":0.4444444444444444},{\"x\":0.2791878172588832,\"y\":0.5}],\"type\":\"rectangle\",\"original_index\":0}"

            actorUnderTest ! ChangeValueRequestV1(
                value = GeomValueV1(geom),
                valueIri = currentGeomValueIri.get,
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: ChangeValueResponseV1 =>
                    currentGeomValueIri.set(msg.id)
                    msg.value should ===(GeomValueV1(geom))
            }
        }

        "add a new text value with Standoff" in {

            val utf8str = "Comment 1aa"

            actorUnderTest ! CreateValueRequestV1(
                resourceIri = zeitglöckleinIri,
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#book_comment",
                value = TextValueWithStandoffV1(utf8str = utf8str, standoff = sampleStandoff, mapping = dummyMapping, mappingIri = "http://rdfh.ch/standoff/mappings/StandardMapping"),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: CreateValueResponseV1 => checkComment1aResponse(msg, utf8str, sampleStandoff)
            }
        }

        "attempt to add a duplicate text value with standoff" in {

            val utf8str = "Comment 1aa"

            actorUnderTest ! CreateValueRequestV1(
                resourceIri = zeitglöckleinIri,
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#book_comment",
                value = TextValueWithStandoffV1(utf8str = utf8str, standoff = sampleStandoff, mapping = dummyMapping, mappingIri = "http://rdfh.ch/standoff/mappings/StandardMapping"),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[DuplicateValueException] should ===(true)
            }

        }

        "add a new version of a text value with Standoff" in {

            val utf8str = "Comment 1bb"

            actorUnderTest ! ChangeValueRequestV1(
                valueIri = commentIri.get,
                value = TextValueWithStandoffV1(utf8str = utf8str, standoff = sampleStandoff, mapping = dummyMapping, mappingIri = "http://rdfh.ch/standoff/mappings/StandardMapping"),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: ChangeValueResponseV1 => checkComment1bResponse(msg, utf8str, sampleStandoff)
            }
        }

        "attempt to add a redundant version of a text value with standoff" in {

            val utf8str = "Comment 1bb"

            actorUnderTest ! ChangeValueRequestV1(
                valueIri = commentIri.get,
                value = TextValueWithStandoffV1(utf8str = utf8str, standoff = sampleStandoff, mapping = dummyMapping, mappingIri = "http://rdfh.ch/standoff/mappings/StandardMapping"),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[DuplicateValueException] should ===(true)
            }

        }

        "add a new text value containing a Standoff resource reference, and create a hasStandoffLinkTo direct link and a corresponding LinkValue" in {
            val textValueWithResourceRef = TextValueWithStandoffV1(
                utf8str = "This comment refers to another resource",
                standoff = Vector(
                    StandoffTagV2(
                        dataType = Some(StandoffDataTypeClasses.StandoffLinkTag),
                        standoffTagClassIri = OntologyConstants.KnoraBase.StandoffLinkTag,
                        startPosition = 31,
                        endPosition = 39,
                        attributes = Vector(StandoffTagIriAttributeV2(standoffPropertyIri = OntologyConstants.KnoraBase.StandoffTagHasLink, value = zeitglöckleinIri)),
                        uuid = UUID.randomUUID().toString,
                        originalXMLID = None,
                        startIndex = 0
                    )
                ),
                resource_reference = Set(zeitglöckleinIri),
                mappingIri = "http://rdfh.ch/standoff/mappings/StandardMapping",
                mapping = dummyMapping
            )

            actorUnderTest ! CreateValueRequestV1(
                resourceIri = "http://rdfh.ch/21abac2162",
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#book_comment",
                value = textValueWithResourceRef,
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case CreateValueResponseV1(newValue: TextValueWithStandoffV1, _, newValueIri: IRI, _) =>
                    firstValueIriWithResourceRef.set(newValueIri)
                    checkTextValue(received = newValue, expected = textValueWithResourceRef)
            }

            actorUnderTest ! LinkValueGetRequestV1(
                subjectIri = "http://rdfh.ch/21abac2162",
                predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                objectIri = zeitglöckleinIri,
                userProfile = incunabulaUser
            )

            // Since this is the first Standoff resource reference between the source and target resources, we should
            // now have version 1 of a LinkValue, with a reference count of 1.

            expectMsgPF(timeout) {
                case msg: ValueGetResponseV1 =>
                    msg.valuetype should ===(OntologyConstants.KnoraBase.LinkValue)
                    msg.value should ===(LinkValueV1(
                        subjectIri = "http://rdfh.ch/21abac2162",
                        predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                        objectIri = zeitglöckleinIri,
                        referenceCount = 1
                    ))
                    msg.rights should ===(2)
            }

            val sparqlQuery = queries.sparql.v1.txt.findLinkValueByObject(
                triplestore = settings.triplestoreType,
                subjectIri = "http://rdfh.ch/21abac2162",
                predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                objectIri = zeitglöckleinIri
            ).toString()

            storeManager ! SparqlSelectRequest(sparqlQuery)

            // The new LinkValue should have no previous version, and there should be a direct link between the resources.

            expectMsgPF(timeout) {
                case response: SparqlSelectResponse =>
                    val rows = response.results.bindings
                    rows.groupBy(_.rowMap("linkValue")).size should ===(1)
                    rows.exists(_.rowMap("objPred") == OntologyConstants.KnoraBase.PreviousValue) should ===(false)
                    rows.head.rowMap.get("directLinkExists").exists(_.toBoolean) should ===(true)
            }

        }

        "add a new version of a text value containing a Standoff resource reference, without needlessly making a new version of the LinkValue" in {
            // The new version contains two references to the same resource.
            val textValueWithResourceRef = TextValueWithStandoffV1(
                utf8str = "This updated comment refers to another resource",
                standoff = Vector(
                        StandoffTagV2(
                            dataType = Some(StandoffDataTypeClasses.StandoffLinkTag),
                            standoffTagClassIri = OntologyConstants.KnoraBase.StandoffLinkTag,
                            startPosition = 39,
                            endPosition = 47,
                            attributes = Vector(StandoffTagIriAttributeV2(standoffPropertyIri = OntologyConstants.KnoraBase.StandoffTagHasLink, value = zeitglöckleinIri)),
                            uuid = UUID.randomUUID().toString,
                            originalXMLID = None,
                            startIndex = 0
                        ),
                        StandoffTagV2(
                            dataType = Some(StandoffDataTypeClasses.StandoffLinkTag),
                            standoffTagClassIri = OntologyConstants.KnoraBase.StandoffLinkTag,
                            startPosition = 0,
                            endPosition = 4,
                            attributes = Vector(StandoffTagIriAttributeV2(standoffPropertyIri = OntologyConstants.KnoraBase.StandoffTagHasLink, value = zeitglöckleinIri)),
                            uuid = UUID.randomUUID().toString,
                            originalXMLID = None,
                            startIndex = 0
                        )
                ),
                resource_reference = Set(zeitglöckleinIri),
                mapping = dummyMapping,
                mappingIri = "http://rdfh.ch/standoff/mappings/StandardMapping"
            )

            actorUnderTest ! ChangeValueRequestV1(
                valueIri = firstValueIriWithResourceRef.get,
                value = textValueWithResourceRef,
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case ChangeValueResponseV1(newValue: TextValueWithStandoffV1, _, newValueIri: IRI, _) =>
                    firstValueIriWithResourceRef.set(newValueIri)
                    checkTextValue(received = newValue, expected = textValueWithResourceRef)
            }

            actorUnderTest ! LinkValueGetRequestV1(
                subjectIri = "http://rdfh.ch/21abac2162",
                predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                objectIri = zeitglöckleinIri,
                userProfile = incunabulaUser
            )

            // Since the new version still refers to the same resource, the reference count of the LinkValue should not
            // change.

            expectMsgPF(timeout) {
                case msg: ValueGetResponseV1 =>
                    msg.valuetype should ===(OntologyConstants.KnoraBase.LinkValue)
                    msg.value should ===(LinkValueV1(
                        subjectIri = "http://rdfh.ch/21abac2162",
                        predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                        objectIri = zeitglöckleinIri,
                        referenceCount = 1
                    ))
                    msg.rights should ===(2)
            }

            val sparqlQuery = queries.sparql.v1.txt.findLinkValueByObject(
                triplestore = settings.triplestoreType,
                subjectIri = "http://rdfh.ch/21abac2162",
                predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                objectIri = zeitglöckleinIri
            ).toString()

            storeManager ! SparqlSelectRequest(sparqlQuery)

            // There should be no new version of the LinkValue, and the direct link should still be there.

            expectMsgPF(timeout) {
                case response: SparqlSelectResponse =>
                    val rows = response.results.bindings
                    rows.groupBy(_.rowMap("linkValue")).size should ===(1)
                    rows.exists(_.rowMap("objPred") == OntologyConstants.KnoraBase.PreviousValue) should ===(false)
                    rows.head.rowMap.get("directLinkExists").exists(_.toBoolean) should ===(true)
            }
        }

        "add another new text value containing a Standoff resource reference, and make a new version of the LinkValue" in {
            val textValueWithResourceRef = TextValueWithStandoffV1(
                utf8str = "This remark refers to another resource",
                standoff = Vector(
                    StandoffTagV2(
                        dataType = Some(StandoffDataTypeClasses.StandoffLinkTag),
                        standoffTagClassIri = OntologyConstants.KnoraBase.StandoffLinkTag,
                        startPosition = 30,
                        endPosition = 38,
                        attributes = Vector(StandoffTagIriAttributeV2(standoffPropertyIri = OntologyConstants.KnoraBase.StandoffTagHasLink, value = zeitglöckleinIri)),
                        uuid = UUID.randomUUID().toString,
                        originalXMLID = None,
                        startIndex = 0
                    )
                ),
                resource_reference = Set(zeitglöckleinIri),
                mapping = dummyMapping,
                mappingIri = "http://rdfh.ch/standoff/mappings/StandardMapping"
            )

            actorUnderTest ! CreateValueRequestV1(
                resourceIri = "http://rdfh.ch/21abac2162",
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#book_comment",
                value = textValueWithResourceRef,
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case CreateValueResponseV1(newValue: TextValueWithStandoffV1, _, newValueIri: IRI, _) =>
                    secondValueIriWithResourceRef.set(newValueIri)
                    checkTextValue(received = newValue, expected = textValueWithResourceRef)
            }

            actorUnderTest ! LinkValueGetRequestV1(
                subjectIri = "http://rdfh.ch/21abac2162",
                predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                objectIri = zeitglöckleinIri,
                userProfile = incunabulaUser
            )

            // Now that we've added a different TextValue that refers to the same resource, we should have version 2
            // of the LinkValue, with a reference count of 2.

            expectMsgPF(timeout) {
                case msg: ValueGetResponseV1 =>
                    msg.valuetype should ===(OntologyConstants.KnoraBase.LinkValue)
                    msg.value should ===(LinkValueV1(
                        subjectIri = "http://rdfh.ch/21abac2162",
                        predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                        objectIri = zeitglöckleinIri,
                        referenceCount = 2
                    ))
                    msg.rights should ===(2)
            }

            val sparqlQuery = queries.sparql.v1.txt.findLinkValueByObject(
                triplestore = settings.triplestoreType,
                subjectIri = "http://rdfh.ch/21abac2162",
                predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                objectIri = zeitglöckleinIri
            ).toString()

            storeManager ! SparqlSelectRequest(sparqlQuery)

            // It should have a previousValue pointing to the previous version, and the direct link should
            // still be there.

            expectMsgPF(timeout) {
                case response: SparqlSelectResponse =>
                    val rows = response.results.bindings
                    rows.groupBy(_.rowMap("linkValue")).size should ===(1)
                    rows.exists(_.rowMap("objPred") == OntologyConstants.KnoraBase.PreviousValue) should ===(true)
                    rows.head.rowMap.get("directLinkExists").exists(_.toBoolean) should ===(true)
            }
        }

        "add a new version of a text value with the Standoff resource reference removed, and make a new version of the LinkValue" in {
            val textValue = TextValueSimpleV1(utf8str = "No resource reference here")

            actorUnderTest ! ChangeValueRequestV1(
                valueIri = firstValueIriWithResourceRef.get,
                value = textValue,
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case ChangeValueResponseV1(newValue: TextValueSimpleV1, _, newValueIri: IRI, _) =>
                    firstValueIriWithResourceRef.set(newValueIri)
                    checkTextValue(received = textValue, expected = newValue)
            }

            actorUnderTest ! LinkValueGetRequestV1(
                subjectIri = "http://rdfh.ch/21abac2162",
                predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                objectIri = zeitglöckleinIri,
                userProfile = incunabulaUser
            )

            // Version 3 of the LinkValue should have a reference count of 1.

            expectMsgPF(timeout) {
                case msg: ValueGetResponseV1 =>
                    msg.valuetype should ===(OntologyConstants.KnoraBase.LinkValue)
                    msg.value should ===(LinkValueV1(
                        subjectIri = "http://rdfh.ch/21abac2162",
                        predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                        objectIri = zeitglöckleinIri,
                        referenceCount = 1
                    ))
                    msg.rights should ===(2)
            }

            val sparqlQuery = queries.sparql.v1.txt.findLinkValueByObject(
                triplestore = settings.triplestoreType,
                subjectIri = "http://rdfh.ch/21abac2162",
                predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                objectIri = zeitglöckleinIri
            ).toString()

            storeManager ! SparqlSelectRequest(sparqlQuery)

            // The LinkValue should point to its previous version, and the direct link should still be there.

            expectMsgPF(timeout) {
                case response: SparqlSelectResponse =>
                    standoffLinkValueIri.set(response.results.bindings.head.rowMap("linkValue"))
                    val rows = response.results.bindings
                    rows.groupBy(_.rowMap("linkValue")).size should ===(1)
                    rows.exists(_.rowMap("objPred") == OntologyConstants.KnoraBase.PreviousValue) should ===(true)
                    rows.head.rowMap.get("directLinkExists").exists(_.toBoolean) should ===(true)
            }

            // The LinkValue should have 3 versions in its version history.

            actorUnderTest ! ValueVersionHistoryGetRequestV1(
                resourceIri = "http://rdfh.ch/21abac2162",
                propertyIri = OntologyConstants.KnoraBase.HasStandoffLinkToValue,
                currentValueIri = standoffLinkValueIri.get,
                userProfile = incunabulaUser
            )

            expectMsgPF(timeout) {
                case msg: ValueVersionHistoryGetResponseV1 => msg.valueVersions.length should ===(3)
            }
        }

        "delete a hasStandoffLinkTo direct link when the reference count of the corresponding LinkValue reaches 0" in {
            val textValue = TextValueSimpleV1(utf8str = "No resource reference here either")

            actorUnderTest ! ChangeValueRequestV1(
                valueIri = secondValueIriWithResourceRef.get,
                value = textValue,
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case ChangeValueResponseV1(newValue: TextValueSimpleV1, _, newValueIri: IRI, _) =>
                    secondValueIriWithResourceRef.set(newValueIri)
                    checkTextValue(received = newValue, expected = textValue)
            }

            // The new version of the LinkValue should be marked as deleted.

            actorUnderTest ! LinkValueGetRequestV1(
                subjectIri = "http://rdfh.ch/21abac2162",
                predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                objectIri = zeitglöckleinIri,
                userProfile = incunabulaUser
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[NotFoundException] should ===(true)
            }

            val sparqlQuery = queries.sparql.v1.txt.findLinkValueByObject(
                triplestore = settings.triplestoreType,
                subjectIri = "http://rdfh.ch/21abac2162",
                predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                objectIri = zeitglöckleinIri,
                includeDeleted = true
            ).toString()

            storeManager ! SparqlSelectRequest(sparqlQuery)

            // The LinkValue should point to its previous version. There should be no direct link.

            expectMsgPF(timeout) {
                case response: SparqlSelectResponse =>
                    standoffLinkValueIri.unset()
                    val rows = response.results.bindings
                    rows.groupBy(_.rowMap("linkValue")).size should ===(1)
                    rows.exists(row => row.rowMap("objPred") == OntologyConstants.KnoraBase.IsDeleted && row.rowMap("objObj").toBoolean) should ===(true)
                    rows.exists(_.rowMap("objPred") == OntologyConstants.KnoraBase.PreviousValue) should ===(true)
                    rows.head.rowMap.get("directLinkExists").exists(_.toBoolean) should ===(false)
            }
        }

        "recreate the hasStandoffLinkTo direct link when a new standoff resource reference is added" in {
            val textValueWithResourceRef = TextValueWithStandoffV1(
                utf8str = "This updated comment refers again to another resource",
                standoff = Vector(
                    StandoffTagV2(
                        dataType = Some(StandoffDataTypeClasses.StandoffLinkTag),
                        standoffTagClassIri = OntologyConstants.KnoraBase.StandoffLinkTag,
                        startPosition = 45,
                        endPosition = 53,
                        attributes = Vector(StandoffTagIriAttributeV2(standoffPropertyIri = OntologyConstants.KnoraBase.StandoffTagHasLink, value = zeitglöckleinIri)),
                        uuid = UUID.randomUUID().toString,
                        originalXMLID = None,
                        startIndex = 0
                    )
                ),
                resource_reference = Set(zeitglöckleinIri),
                mapping = dummyMapping,
                mappingIri = "http://rdfh.ch/standoff/mappings/StandardMapping"
            )

            actorUnderTest ! ChangeValueRequestV1(
                valueIri = firstValueIriWithResourceRef.get,
                value = textValueWithResourceRef,
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case ChangeValueResponseV1(newValue: TextValueWithStandoffV1, _, newValueIri: IRI, _) =>
                    firstValueIriWithResourceRef.set(newValueIri)
                    checkTextValue(received = newValue, expected = textValueWithResourceRef)
            }

            actorUnderTest ! LinkValueGetRequestV1(
                subjectIri = "http://rdfh.ch/21abac2162",
                predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                objectIri = zeitglöckleinIri,
                userProfile = incunabulaUser
            )

            // There should now be a new LinkValue with no previous versions and a reference count of 1, and
            // there should once again be a direct link.

            expectMsgPF(timeout) {
                case msg: ValueGetResponseV1 =>
                    msg.valuetype should ===(OntologyConstants.KnoraBase.LinkValue)
                    msg.value should ===(LinkValueV1(
                        subjectIri = "http://rdfh.ch/21abac2162",
                        predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                        objectIri = zeitglöckleinIri,
                        referenceCount = 1
                    ))
                    msg.rights should ===(2)
            }

            val sparqlQuery = queries.sparql.v1.txt.findLinkValueByObject(
                triplestore = settings.triplestoreType,
                subjectIri = "http://rdfh.ch/21abac2162",
                predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                objectIri = zeitglöckleinIri
            ).toString()

            storeManager ! SparqlSelectRequest(sparqlQuery)

            expectMsgPF(timeout) {
                case response: SparqlSelectResponse =>
                    val rows = response.results.bindings
                    rows.groupBy(_.rowMap("linkValue")).size should ===(1)
                    rows.exists(_.rowMap("objPred") == OntologyConstants.KnoraBase.PreviousValue) should ===(false)
                    rows.head.rowMap.get("directLinkExists").exists(_.toBoolean) should ===(true)
            }
        }

        "add a new Integer value (seqnum of a page)" in {

            val seqnum = 4

            actorUnderTest ! CreateValueRequestV1(
                resourceIri = "http://rdfh.ch/8a0b1e75",
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#seqnum",
                value = IntegerValueV1(seqnum),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case CreateValueResponseV1(newValue: IntegerValueV1, _, newValueIri: IRI, _) =>
                    currentSeqnumValueIri.set(newValueIri)
                    newValue should ===(IntegerValueV1(seqnum))
            }
        }

        "change an existing Integer value (seqnum of a page)" in {

            val seqnum = 8

            actorUnderTest ! ChangeValueRequestV1(
                value = IntegerValueV1(seqnum),
                userProfile = incunabulaUser,
                valueIri = currentSeqnumValueIri.get,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case ChangeValueResponseV1(newValue: IntegerValueV1, _, newValueIri: IRI, _) =>
                    newValue should ===(IntegerValueV1(seqnum))
            }
        }

        "add a new Date value (pubdate of a book)" in {

            // great resource to verify that expected conversion result from and to JDC is correct:
            // https://www.fourmilab.ch/documents/calendar/
            actorUnderTest ! CreateValueRequestV1(
                resourceIri = "http://rdfh.ch/21abac2162",
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#pubdate",
                value = JulianDayNumberValueV1(
                    dateval1 = 2451545,
                    dateval2 = 2457044,
                    dateprecision1 = KnoraPrecisionV1.YEAR,
                    dateprecision2 = KnoraPrecisionV1.DAY,
                    calendar = KnoraCalendarV1.GREGORIAN
                ),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: CreateValueResponseV1 =>
                    currentPubdateValueIri.set(msg.id)
                    msg.value should ===(DateValueV1("2000", "2015-01-21", "CE","CE", KnoraCalendarV1.GREGORIAN))
            }
        }

        "change an existing date (pubdate of a book)" in {

            actorUnderTest ! ChangeValueRequestV1(
                value = JulianDayNumberValueV1(
                    dateval1 = 2265854,
                    dateval2 = 2265854,
                    dateprecision1 = KnoraPrecisionV1.DAY,
                    dateprecision2 = KnoraPrecisionV1.DAY,
                    calendar = KnoraCalendarV1.JULIAN
                ),
                userProfile = incunabulaUser,
                valueIri = currentPubdateValueIri.get,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: ChangeValueResponseV1 =>
                    currentPubdateValueIri.set(msg.id)
                    msg.value should ===(DateValueV1("1491-07-28", "1491-07-28", "CE", "CE", KnoraCalendarV1.JULIAN))
            }

        }

        "create a link between two resources" in {
            val createValueRequest = CreateValueRequestV1(
                resourceIri = "http://rdfh.ch/cb1a74e3e2f6",
                propertyIri = OntologyConstants.KnoraBase.HasLinkTo,
                value = LinkUpdateV1(
                    targetResourceIri = zeitglöckleinIri
                ),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            actorUnderTest ! createValueRequest

            expectMsgPF(timeout) {
                case CreateValueResponseV1(linkV1: LinkV1, _, newLinkValueIri: IRI, _) =>
                    linkObjLinkValueIri.set(newLinkValueIri)
                    linkV1.targetResourceIri should ===(zeitglöckleinIri)
                    linkV1.valueResourceClass should ===(Some("http://www.knora.org/ontology/0803/incunabula#book"))
            }

            // The new LinkValue should have no previous version, and there should be a direct link between the resources.

            val sparqlQuery = queries.sparql.v1.txt.findLinkValueByObject(
                triplestore = settings.triplestoreType,
                subjectIri = "http://rdfh.ch/cb1a74e3e2f6",
                predicateIri = OntologyConstants.KnoraBase.HasLinkTo,
                objectIri = zeitglöckleinIri
            ).toString()

            storeManager ! SparqlSelectRequest(sparqlQuery)

            expectMsgPF(timeout) {
                case response: SparqlSelectResponse =>
                    val rows = response.results.bindings
                    rows.groupBy(_.rowMap("linkValue")).size should ===(1)
                    rows.exists(_.rowMap("objPred") == OntologyConstants.KnoraBase.PreviousValue) should ===(false)
                    rows.head.rowMap.get("directLinkExists").exists(_.toBoolean) should ===(true)
            }
        }

        "not create a duplicate link" in {
            val createValueRequest = CreateValueRequestV1(
                resourceIri = "http://rdfh.ch/cb1a74e3e2f6",
                propertyIri = OntologyConstants.KnoraBase.HasLinkTo,
                value = LinkUpdateV1(
                    targetResourceIri = zeitglöckleinIri
                ),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            actorUnderTest ! createValueRequest

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[DuplicateValueException] should ===(true)
            }
        }

        "not create a link that points to a resource of the wrong class" in {
            actorUnderTest ! CreateValueRequestV1(
                resourceIri = miscResourceIri,
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#miscHasBook", // can only point to an incunabula:book
                value = LinkUpdateV1(
                    targetResourceIri = "http://rdfh.ch/8a0b1e75" // an incunabula:page, not an incunabula:book
                ),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[OntologyConstraintException] should ===(true)
            }
        }

        "change a link" in {
            val linkSourceIri = "http://rdfh.ch/cb1a74e3e2f6"
            val linkTargetIri = "http://rdfh.ch/21abac2162"
            val lastModBeforeUpdate = getLastModificationDate(linkSourceIri)

            val changeValueRequest = ChangeValueRequestV1(
                value = LinkUpdateV1(
                    targetResourceIri = linkTargetIri
                ),
                userProfile = incunabulaUser,
                valueIri = linkObjLinkValueIri.get,
                apiRequestID = UUID.randomUUID
            )

            actorUnderTest ! changeValueRequest

            expectMsgPF(timeout) {
                case ChangeValueResponseV1(linkValue: LinkV1, _, newLinkValueIri: IRI, _) =>
                    linkObjLinkValueIri.set(newLinkValueIri)
                    linkValue.targetResourceIri should ===(linkTargetIri)
            }

            // The old LinkValue should be deleted now, and the old direct link should have been removed.

            val oldLinkValueSparqlQuery = queries.sparql.v1.txt.findLinkValueByObject(
                triplestore = settings.triplestoreType,
                subjectIri = linkSourceIri,
                predicateIri = OntologyConstants.KnoraBase.HasLinkTo,
                objectIri = zeitglöckleinIri,
                includeDeleted = true
            ).toString()

            storeManager ! SparqlSelectRequest(oldLinkValueSparqlQuery)

            expectMsgPF(timeout) {
                case response: SparqlSelectResponse =>
                    val rows = response.results.bindings
                    rows.groupBy(_.rowMap("linkValue")).size should ===(1)
                    rows.exists(row => row.rowMap("objPred") == OntologyConstants.KnoraBase.IsDeleted && row.rowMap("objObj").toBoolean) should ===(true)
                    rows.exists(_.rowMap("objPred") == OntologyConstants.KnoraBase.PreviousValue) should ===(true)
                    rows.head.rowMap.get("directLinkExists").exists(_.toBoolean) should ===(false)
            }

            // The new LinkValue should have no previous version, and there should be a direct link between the resources.

            val newLinkValueSparqlQuery = queries.sparql.v1.txt.findLinkValueByObject(
                triplestore = settings.triplestoreType,
                subjectIri = linkSourceIri,
                predicateIri = OntologyConstants.KnoraBase.HasLinkTo,
                objectIri = linkTargetIri
            ).toString()

            storeManager ! SparqlSelectRequest(newLinkValueSparqlQuery)

            expectMsgPF(timeout) {
                case response: SparqlSelectResponse =>
                    val rows = response.results.bindings
                    rows.groupBy(_.rowMap("linkValue")).size should ===(1)
                    rows.exists(_.rowMap("objPred") == OntologyConstants.KnoraBase.PreviousValue) should ===(false)
                    rows.head.rowMap.get("directLinkExists").exists(_.toBoolean) should ===(true)
            }

            // Check that the link source's last modification date got updated.
            val lastModAfterUpdate = getLastModificationDate(linkSourceIri)
            lastModBeforeUpdate != lastModAfterUpdate should ===(true)
        }

        "delete a link between two resources" in {

            val linkSourceIri = "http://rdfh.ch/cb1a74e3e2f6"
            val linkTargetIri = "http://rdfh.ch/21abac2162"
            val lastModBeforeUpdate = getLastModificationDate(linkSourceIri)

            val comment = "This link is no longer needed"

            actorUnderTest ! DeleteValueRequestV1(
                valueIri = linkObjLinkValueIri.get,
                deleteComment = Some(comment),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: DeleteValueResponseV1 => linkObjLinkValueIri.set(msg.id)
            }

            val deletedLinkValueSparqlQuery = queries.sparql.v1.txt.findLinkValueByObject(
                triplestore = settings.triplestoreType,
                subjectIri = linkSourceIri,
                predicateIri = OntologyConstants.KnoraBase.HasLinkTo,
                objectIri = linkTargetIri,
                includeDeleted = true
            ).toString()

            storeManager ! SparqlSelectRequest(deletedLinkValueSparqlQuery)

            expectMsgPF(timeout) {
                case response: SparqlSelectResponse =>
                    val rows = response.results.bindings
                    rows.groupBy(_.rowMap("linkValue")).size should ===(1)
                    rows.exists(row => row.rowMap("objPred") == OntologyConstants.KnoraBase.IsDeleted && row.rowMap("objObj").toBoolean) should ===(true)
                    rows.exists(_.rowMap("objPred") == OntologyConstants.KnoraBase.PreviousValue) should ===(true)
                    rows.head.rowMap.get("directLinkExists").exists(_.toBoolean) should ===(false)
                    rows.exists(row => row.rowMap("objPred") == OntologyConstants.KnoraBase.ValueHasComment && row.rowMap("objObj") == comment) should ===(true)
            }

            // Check that the link source's last modification date got updated.
            val lastModAfterUpdate = getLastModificationDate(linkSourceIri)
            lastModBeforeUpdate != lastModAfterUpdate should ===(true)
        }

        "change the partOf property of a page" in {

            // A test UserProfile.
            val userProfile = SharedTestDataADM.incunabulaCreatorUser

            val linkTargetIri = "http://rdfh.ch/e41ab5695c"

            partOfLinkValueIri.set("http://rdfh.ch/8a0b1e75/values/3a7b5130-22c2-4400-a794-062b7a3e3436")

            val changeValueRequest = ChangeValueRequestV1(
                value = LinkUpdateV1(
                    targetResourceIri = linkTargetIri
                ),
                userProfile = userProfile,
                valueIri = partOfLinkValueIri.get,
                apiRequestID = UUID.randomUUID
            )

            actorUnderTest ! changeValueRequest

            expectMsgPF(timeout) {
                case ChangeValueResponseV1(linkValue: LinkV1, _, newLinkValueIri: IRI, _) =>
                    // save valueIri for next test
                    partOfLinkValueIri.set(newLinkValueIri)
                    linkValue.targetResourceIri should ===(linkTargetIri)
            }

        }

        "try to change the partOf property of a page, but submit the current target Iri" in {

            // A test UserADM.
            val userProfile = SharedTestDataADM.incunabulaProjectAdminUser

            val linkTargetIri = "http://rdfh.ch/e41ab5695c"

            val changeValueRequest = ChangeValueRequestV1(
                value = LinkUpdateV1(
                    targetResourceIri = linkTargetIri
                ),
                userProfile = userProfile,
                valueIri = partOfLinkValueIri.get, // use valueIri from previous test
                apiRequestID = UUID.randomUUID
            )

            actorUnderTest ! changeValueRequest

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[DuplicateValueException] should ===(true)
            }

        }

        "add a new text value with a comment" in {
            val comment = "This is a comment"
            val metaComment = "This is a metacomment"

            actorUnderTest ! CreateValueRequestV1(
                resourceIri = zeitglöckleinIri,
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#book_comment",
                value = TextValueSimpleV1(utf8str = comment),
                comment = Some(metaComment),
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: CreateValueResponseV1 =>
                    msg.value.toString should ===(comment)
                    msg.comment should ===(Some(metaComment))
            }
        }

        "add a comment to a value" in {
            val lastModBeforeUpdate = getLastModificationDate(zeitglöckleinIri)

            val comment = Some("This is wrong. I am the author!")

            val changeCommentRequest = ChangeCommentRequestV1(
                valueIri = "http://rdfh.ch/c5058f3a/values/8653a672",
                comment = comment,
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            actorUnderTest ! changeCommentRequest

            expectMsgPF(timeout) {
                case msg: ChangeValueResponseV1 =>
                    msg.value should ===(TextValueSimpleV1(utf8str = "Berthold, der Bruder"))
                    msg.comment should ===(comment)
            }

            // Check that the resource's last modification date got updated.
            val lastModAfterUpdate = getLastModificationDate(zeitglöckleinIri)
            lastModBeforeUpdate != lastModAfterUpdate should ===(true)
        }

        "add a new image file value to an incunabula:page" in {

            val fileRequest = SipiResponderConversionFileRequestV1(
                originalFilename = "Chlaus.jpg",
                originalMimeType = "image/jpeg",
                filename = "./test_server/images/Chlaus.jpg",
                userProfile = incunabulaUser.asUserProfileV1
            )

            val fileChangeRequest = ChangeFileValueRequestV1(
                resourceIri = "http://rdfh.ch/8a0b1e75",
                file = fileRequest,
                apiRequestID = UUID.randomUUID,
                userProfile = incunabulaUser)

            actorUnderTest ! fileChangeRequest

            expectMsgPF(timeout) {
                case msg: ChangeFileValueResponseV1 => checkImageFileValueChange(msg, fileChangeRequest)
            }

        }

        "change the season of a image:bild from summer to winter" in {

            val winter = "http://rdfh.ch/lists/00FF/eda2792605"

            actorUnderTest ! ChangeValueRequestV1(
                value = HierarchicalListValueV1(winter),
                userProfile = imagesUser,
                valueIri = "http://rdfh.ch/d208fb9357d5/values/bc90a9c5091004",
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case ChangeValueResponseV1(newListValue: HierarchicalListValueV1, _, _, _) =>
                    newListValue should ===(HierarchicalListValueV1(winter))
            }

        }

        "create a season of a image:bild" in {

            val summer = "http://rdfh.ch/lists/00FF/526f26ed04"

            actorUnderTest ! CreateValueRequestV1(
                value = HierarchicalListValueV1(summer),
                userProfile = imagesUser,
                propertyIri = s"$IMAGES_ONTOLOGY_IRI#jahreszeit",
                resourceIri = "http://rdfh.ch/691e7e2244d5",
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case CreateValueResponseV1(newListValue: HierarchicalListValueV1, _, _, _) =>
                    newListValue should ===(HierarchicalListValueV1(summer))
            }

        }

        "add a decimal value to an anything:Thing" in {
            val decimalValue = DecimalValueV1(BigDecimal("5.6"))

            actorUnderTest ! CreateValueRequestV1(
                value = decimalValue,
                userProfile = anythingUser,
                propertyIri = "http://www.knora.org/ontology/0001/anything#hasDecimal",
                resourceIri = aThingIri,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case CreateValueResponseV1(newDecimalValue: DecimalValueV1, _, _, _) =>
                    newDecimalValue should ===(decimalValue)
            }
        }

        "add an interval value to an anything:Thing" in {
            val intervalValue = IntervalValueV1(timeval1 = BigDecimal("1000000000000000.0000000000000001"), timeval2 = BigDecimal("1000000000000000.0000000000000002"))

            actorUnderTest ! CreateValueRequestV1(
                value = intervalValue,
                userProfile = anythingUser,
                propertyIri = "http://www.knora.org/ontology/0001/anything#hasInterval",
                resourceIri = aThingIri,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case CreateValueResponseV1(newIntervalValue: IntervalValueV1, _, _, _) =>
                    newIntervalValue should ===(intervalValue)
            }
        }

        "add a color value to an anything:Thing" in {
            val colorValue = ColorValueV1("#4169E1")

            actorUnderTest ! CreateValueRequestV1(
                value = colorValue,
                userProfile = anythingUser,
                propertyIri = "http://www.knora.org/ontology/0001/anything#hasColor",
                resourceIri = aThingIri,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case CreateValueResponseV1(newColorValue: ColorValueV1, _, _, _) =>
                    newColorValue should ===(colorValue)
            }
        }

        // TODO: commented out because of compaibility issues with the GUI
        /*"add a geometry value to an anything:Thing" in {
            val geomValue = GeomValueV1("{\"status\":\"active\",\"lineColor\":\"#ff3333\",\"lineWidth\":2,\"points\":[{\"x\":0.5516074450084602,\"y\":0.4444444444444444},{\"x\":0.2791878172588832,\"y\":0.5}],\"type\":\"rectangle\",\"original_index\":0}")

            actorUnderTest ! CreateValueRequestV1(
                value = geomValue,
                userProfile = anythingUser,
                propertyIri = "http://www.knora.org/ontology/0001/anything#hasGeometry",
                resourceIri = aThingIri,
                projectIri = anythingProjectIri,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case CreateValueResponseV1(newGeomValue: GeomValueV1, _ , _, _, _) =>
                    newGeomValue should ===(geomValue)
            }
        }

        "add a geoname value to an anything:Thing" in {
            val geonameValue = GeonameValueV1("2661602")

            actorUnderTest ! CreateValueRequestV1(
                value = geonameValue,
                userProfile = anythingUser,
                propertyIri = "http://www.knora.org/ontology/0001/anything#hasGeoname",
                resourceIri = aThingIri,
                projectIri = anythingProjectIri,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case CreateValueResponseV1(newGeonameValue: GeonameValueV1, _ , _, _, _) =>
                    newGeonameValue should ===(geonameValue)
            }
        }*/

        "add a boolean value to an anything:Thing" in {
            val booleanValue = BooleanValueV1(true)

            actorUnderTest ! CreateValueRequestV1(
                value = booleanValue,
                userProfile = anythingUser,
                propertyIri = "http://www.knora.org/ontology/0001/anything#hasBoolean",
                resourceIri = aThingIri,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case CreateValueResponseV1(newBooleanValue: BooleanValueV1, _ , _, _) =>
                    newBooleanValue should ===(booleanValue)
            }
        }

        "add a URI value to an anything:Thing" in {
            val uriValue = UriValueV1("http://dhlab.unibas.ch")

            actorUnderTest ! CreateValueRequestV1(
                value = uriValue,
                userProfile = anythingUser,
                propertyIri = "http://www.knora.org/ontology/0001/anything#hasUri",
                resourceIri = aThingIri,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case CreateValueResponseV1(newUriValue: UriValueV1, _, _, _) =>
                    newUriValue should ===(uriValue)
            }
        }

        "delete two text values containing the same standoff resource reference" in {
            val thingWithTextValues = "http://rdfh.ch/0001/a-thing-with-text-values"
            val firstTextValue = "http://rdfh.ch/0001/a-thing-with-text-values/values/1"
            val secondTextValue = "http://rdfh.ch/0001/a-thing-with-text-values/values/2"
            val lastModBeforeFirstDelete = getLastModificationDate(thingWithTextValues)

            // Check that the link value has an initial reference count of 2.

            actorUnderTest ! LinkValueGetRequestV1(
                subjectIri = thingWithTextValues,
                predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                objectIri = aThingIri,
                userProfile = anythingUser
            )

            expectMsgPF(timeout) {
                case msg: ValueGetResponseV1 =>
                    msg.valuetype should ===(OntologyConstants.KnoraBase.LinkValue)
                    msg.value should ===(LinkValueV1(
                        subjectIri = thingWithTextValues,
                        predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                        objectIri = aThingIri,
                        referenceCount = 2
                    ))
                    msg.rights should ===(2)
            }

            val initialLinkValueSparqlQuery = queries.sparql.v1.txt.findLinkValueByObject(
                triplestore = settings.triplestoreType,
                subjectIri = thingWithTextValues,
                predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                objectIri = aThingIri
            ).toString()

            storeManager ! SparqlSelectRequest(initialLinkValueSparqlQuery)

            // It should have no previousValue, and the direct link should exist.

            expectMsgPF(timeout) {
                case response: SparqlSelectResponse =>
                    val rows = response.results.bindings
                    rows.groupBy(_.rowMap("linkValue")).size should ===(1)
                    rows.exists(_.rowMap("objPred") == OntologyConstants.KnoraBase.PreviousValue) should ===(false)
                    rows.head.rowMap.get("directLinkExists").exists(_.toBoolean) should ===(true)
            }

            // Now delete the first text value.

            actorUnderTest ! DeleteValueRequestV1(
                valueIri = firstTextValue,
                userProfile = anythingUser,
                apiRequestID = UUID.randomUUID
            )

            val deletedFirstTextValue = expectMsgPF(timeout) {
                case msg: DeleteValueResponseV1 => msg.id
            }

            actorUnderTest ! ValueGetRequestV1(
                valueIri = deletedFirstTextValue,
                userProfile = anythingUser
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[NotFoundException] should ===(true)
            }

            // Check that the resource's last modification date got updated.
            val lastModAfterFirstDelete = getLastModificationDate(thingWithTextValues)
            lastModBeforeFirstDelete != lastModAfterFirstDelete should ===(true)

            // The link value should now have a reference count of 1.

            actorUnderTest ! LinkValueGetRequestV1(
                subjectIri = thingWithTextValues,
                predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                objectIri = aThingIri,
                userProfile = anythingUser
            )

            expectMsgPF(timeout) {
                case msg: ValueGetResponseV1 =>
                    msg.valuetype should ===(OntologyConstants.KnoraBase.LinkValue)
                    msg.value should ===(LinkValueV1(
                        subjectIri = thingWithTextValues,
                        predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                        objectIri = aThingIri,
                        referenceCount = 1
                    ))
                    msg.rights should ===(2)
            }

            // It should have a previousValue, and the direct link should still exist.

            val decrementedLinkValueSparqlQuery = queries.sparql.v1.txt.findLinkValueByObject(
                triplestore = settings.triplestoreType,
                subjectIri = thingWithTextValues,
                predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                objectIri = aThingIri
            ).toString()

            storeManager ! SparqlSelectRequest(decrementedLinkValueSparqlQuery)

            expectMsgPF(timeout) {
                case response: SparqlSelectResponse =>
                    val rows = response.results.bindings
                    rows.groupBy(_.rowMap("linkValue")).size should ===(1)
                    rows.exists(_.rowMap("objPred") == OntologyConstants.KnoraBase.PreviousValue) should ===(true)
                    rows.head.rowMap.get("directLinkExists").exists(_.toBoolean) should ===(true)
            }

            // Now delete the second text value.

            actorUnderTest ! DeleteValueRequestV1(
                valueIri = secondTextValue,
                userProfile = anythingUser,
                apiRequestID = UUID.randomUUID
            )

            val deletedSecondTextValue = expectMsgPF(timeout) {
                case msg: DeleteValueResponseV1 => msg.id
            }

            actorUnderTest ! ValueGetRequestV1(
                valueIri = deletedSecondTextValue,
                userProfile = anythingUser
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[NotFoundException] should ===(true)
            }

            // Check that the resource's last modification date got updated.
            val lastModAfterSecondDelete = getLastModificationDate(thingWithTextValues)
            lastModBeforeFirstDelete != lastModAfterSecondDelete should ===(true)

            // The new version of the LinkValue should be marked as deleted.

            actorUnderTest ! LinkValueGetRequestV1(
                subjectIri = thingWithTextValues,
                predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                objectIri = aThingIri,
                userProfile = anythingUser
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure => msg.cause.isInstanceOf[NotFoundException] should ===(true)
            }

            // The LinkValue should point to its previous version. There should be no direct link.

            val deletedLinkValueSparqlQuery = queries.sparql.v1.txt.findLinkValueByObject(
                triplestore = settings.triplestoreType,
                subjectIri = thingWithTextValues,
                predicateIri = OntologyConstants.KnoraBase.HasStandoffLinkTo,
                objectIri = aThingIri,
                includeDeleted = true
            ).toString()

            storeManager ! SparqlSelectRequest(deletedLinkValueSparqlQuery)

            expectMsgPF(timeout) {
                case response: SparqlSelectResponse =>
                    standoffLinkValueIri.unset()
                    val rows = response.results.bindings
                    rows.groupBy(_.rowMap("linkValue")).size should ===(1)
                    rows.exists(row => row.rowMap("objPred") == OntologyConstants.KnoraBase.IsDeleted && row.rowMap("objObj").toBoolean) should ===(true)
                    rows.exists(_.rowMap("objPred") == OntologyConstants.KnoraBase.PreviousValue) should ===(true)
                    rows.head.rowMap.get("directLinkExists").exists(_.toBoolean) should ===(false)
            }
        }

        "not add a text value containing a standoff reference to a nonexistent resource" in {
            val nonexistentIri = "http://rdfh.ch/nonexistent"

            val textValueWithResourceRef = TextValueWithStandoffV1(
                utf8str = "This comment refers to another resource",
                standoff = Vector(
                    StandoffTagV2(
                        standoffTagClassIri = OntologyConstants.KnoraBase.StandoffLinkTag,
                        dataType = Some(StandoffDataTypeClasses.StandoffLinkTag),
                        startPosition = 31,
                        endPosition = 39,
                        startIndex = 0,
                        attributes = Vector(StandoffTagIriAttributeV2(standoffPropertyIri = OntologyConstants.KnoraBase.StandoffTagHasLink, value = nonexistentIri)),
                        uuid = UUID.randomUUID().toString,
                        originalXMLID = None
                    )
                ),
                resource_reference = Set(nonexistentIri),
                mapping = ResourcesResponderV1SpecFullData.dummyMapping,
                mappingIri = "http://rdfh.ch/standoff/mappings/StandardMapping"
            )

            actorUnderTest ! CreateValueRequestV1(
                resourceIri = zeitglöckleinIri,
                propertyIri = "http://www.knora.org/ontology/0803/incunabula#book_comment",
                value = textValueWithResourceRef,
                userProfile = incunabulaUser,
                apiRequestID = UUID.randomUUID
            )

            expectMsgPF(timeout) {
                case msg: akka.actor.Status.Failure =>
                    msg.cause.isInstanceOf[NotFoundException] should ===(true)
            }
        }

        "add a new text value with language" in {

            actorUnderTest ! CreateValueRequestV1(
                value = TextValueSimpleV1(utf8str = "Hello World!", language= Some("en")),
                userProfile = anythingUser,
                propertyIri = "http://www.knora.org/ontology/0001/anything#hasText",
                resourceIri = "http://rdfh.ch/0001/a-thing-with-text-valuesLanguage",
                apiRequestID = UUID.randomUUID
            )

                expectMsgPF(timeout) {
                    case msg: CreateValueResponseV1 =>
                        msg.value should ===(TextValueSimpleV1(utf8str = "Hello World!", language = Some("en")))

                }
        }

    }
}
